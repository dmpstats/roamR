---
title: "`roamR` - User guide"
output: 
  html_document:
    number_sections: true
    theme: cerulean
    toc: yes
    toc_float:
      collapsed: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
library(roamR)
```

# Overview

`roamR` is an R package that offers a toolset and framework for running Individual Based Models (IBMs - or Agent-Based Models). It was created as part of the DisNBS project (Distribution of seabirds in the Non-Breeding Season) which was a project within the Off-shore Renewables Joint Industry Partnership programme ([ORJIP](http://www.orjip.org.uk/)). While the project has specific goals in relation to Off-shore Wind Farms (OWF) and their potential effects on seabirds, the problem is quite general. This package can help build animal movement simulations, with the general problem broken down into logical components and imposes a level of transparent formality, such that the computational components are on a common footing, leaving focus on parametrisation and inputs/data.


## Project

* DisNBS project and associated credits
* Objectives


## A scenario

IBMs are simple in principle - they simulate the movement of individual animals in response to their environment and measure properties from them e.g. their body-mass. They are particularly useful where analytical modelling is difficult and where "what-if" scenarios are sought, where the system can be examined with/without a speculative perturbation. They also accommodate stochasticity/uncertainty quite naturally. Typically many are run such that uncertainty in the inputs are reflected in any measured outputs, so conclusions are tempered accordingly.

The DisNBS project serves as a motivating example. ... etc OWF blah

## Package overview

`roamR` is written in S4 and has been structured/implemented such that the simulations are well defined, but with a lot of flexibility in what the components can do. Animal IBMs are spatio-temporal and can be based on very disparate data sources - so `roamR` is particular in its treatment of space (projections etc), time and units generally (as found in the `units` package). The package was written with animals in mind (indeed one of the main classes is `Species`), but we'll use the agnostic term __agent__.

In brief - `roamR`:

- defines the environment the animal interacts with, and how this functionally affects its movement or behaviour
- defines how animals move, with consideration of the environment, behavoural state, or condition
- defines the behaviours animals may engage in and how these change
- defines the general characteristics of a type of agent (a _species_ definition)
- creates many agents with stochastic properties in line with their species definition
- runs the agents through the simulated environment over time, for a defined temporal resolution
- measures the agents throughout the simulation
- gives tools to query the mass of agents that have been simulated

A principal limitation in IBMs is the level of information you have about how the agents behave. `roamR` is intended to work with very little information, up to very information rich. The test cases here cover a range of data support:

- Relatively data rich: Guillemots at the Isle of May, which are well studied.
- Relatively data poor: Red-Throated Divers in the North Sea, which are less understood.

In the more extreme, `roamR` has been developed with the intention of simulating very well known animal populations, for example a population with extensive GPS tagging information, that might suffice for estimation of a Hidden Markov Model. For example those demonstrated in Michelot XXX fitted to Fulmar, which could be subsequently simulated in the momentHMM package.  

## R and S4 programming

This package assumes at least some minor familiarity with R. Its use for simulating birds in the context of OWF is illustrated using markdown in the associated example scenarios - so no deep R programming is required. These examples give the steps required which can be modified and followed for new cases. However, even within this use-case it is unavoidable that user-defined functions will be required: for example the energetics equations for a particular species' activity states. There are a lot of features of the package that extend it well beyond these OWF seabird examples, but will require a deeper understanding of R.


`roamR` is written in S4 and some familiarity with this is useful generally, but particularly if you want to use the package beyond the narrow path for the bird IBMs that motivated the package. However, there is some basic S4 information that is useful to bear in mind:

* There are well-defined classes for many components of the simulation - the R objects will often contain _slots_ that you access by name with the `@` operator, as opposed to the `$` that is common for simple R objects.
* Classes are prescriptive in what they can contain, this means things are more robust but deviations will be rejected e.g. if the data is __required__ to be a `stars` object, you cannot store something else there
* There are a lot of background checks for conformity (as above), so what you do will be scrutinised at various levels and prevented if  

## Dependencies

The package has been written with the intention of few dependencies on other packages. The dependencies that are needed have been chosen with stability and longevity in mind i.e. they are well maintained and programmed, where differing options are available. Notable examples are:

* The `sf` (simple features) package, which is widely well regarded for spatial work and encompasses much functionality of other packages. 
* The `stars` packages for dealing with spatiotemporal data structures, which is characteristic of much of the data required for animal movement IBMs.


# Package/class hierarchy

A great deal of thought has gone into the hierarchical structure, which means mainly the classes, how they relate to one another and therefore where data (including parameters) lies within these. This is summarised in figure 1 below:

![figure 1](images/roamR_schema.png)

Key elements of this are discussed in turn, and examples are given in the associated test scenarios. Four main areas are covered:

* The simulation engine and wrapper - offering high-level controls, like the number of agents, spatial/temporal boundaries (e.g. a bounding box, as distinct to environmental constraints of the simulation, fundamental spatial coordinate system
* The species - properties of the population being simulated e.g. distributions of initial body mass, flying speeds. These are often distributional, as agents/individuals will be generate from these. 
* The environment - spatiotemporal descriptions of the agent's environment within the simulation frame e.g. natural boundaries (coast), the Sea Surface Temperature (SST) over time, man-made structures (e.g. OWF)
* The agents - the basic simulation element, largely defined from higher components, but the basis of monitoring the simulation and any counterfactuals 

The workflow is in essence:

1. Configure the simulation at a high-level, including the spatial and temporal boundaries, projections, number of agents etc.
1. Define the species, for example initial body mass distributions, flight speed distributions, activity states and their energetic implications, functional relationships between the species and the environment e.g. how SST affects energy, how OWFs influence movement/distribution.
1. Define the environment, essentially anything spatio-temporal that the animals are thought to respond to - coastline, man-made structures (e.g. OWF), prey distributions, SST, bathymetry etc
1. Combine components into an IBM object
1. Run a simulation, which creates agents, moves them through the environment, and records their properties over time
1. Alter simulation elements to reflect a perturbation (presence of OWF)
1. Re-run the simulation with the perturbation
1. Query simulated animals, with counterfactuals as needed based on within-agent comparisons over perturbation scenarios



# The high level control (`ModelConfig`, class)

This provides the high-level configurations for the simulation, such as the spatial and temporal boundaries, the spatiotemporal resolution, the number of agents to simulate, the projection of the spatial data, and other general parameters that define the simulation environment. This also includes start and finish points for simulated animals, if that some return-to-colony behaviour is required. Consideration in the setting of these follows.

__Bounding Box__ (`aoc_bbx`) this is a spatial extent over which the agents are constrained to be within. In many cases this will simply dictated by the data, for example a density distribution for the animal being simulated. If the animals have very low probability of being beyond this data, then the bounding box constraint is a logical progression. In other cases it might be set with knowledge of the maximum range of the animal's homerange. 

It is important to note that no movement outside this is permitted - so the box should be sufficiently large that it is not controversially influential i.e. err on the large side given other inputs will dictate travel. It also will bound spatiotemporal inputs, so data inputs are clipped to this region. A potential consequence of making the bounds very large is that large amounts of data be retained needlessly.

__Spatial Resolution__ (`delta_x`, `delta_y`) this defines the resolution of any spatiotemporal datacubes that underpin the IBM. Note, this does not define the resolution of the movements of the agent, just the resolution of data describing its environment. This can simply be set to match the finest scale of the input data, the only cost being the size of data being carried forwards.

__Temporal Bounds__ (`start_date`, `end_date`) a nominal period the simulation applies to. Some care is needed such that input data covers this period. For example, if the simulation is envisaged to be running in the future, temporal inputs should similarly be nominally for this period e.g. if using historic SST data, this needs to be timestamped for the projected simulation period.

__Number of agents__ (`n_agents`) there is no strong guidance on this, but is should be a considered choice. A general rule of thumb is that more would be better (similar to any computer intensive inference) so should be "large". Note, the amount of calculation, and hence time to run the simulation, is linear with regards this. Similarly agents are tracked and stored in detail, so may result in non-negligible storage sizes. 

Ultimately the the outputs will be distributions of metrics from the agents, so sufficient are needed to characterise these distributions well/stably. A balance of computation time and accuracy of the distribution shape may be needed, if computation time is large - else just select a large number. The number of agents does _not_ need to match the number of individuals in the population being simulated, they represent a sample of potential realities or animals as for any computer-intensive inference.


# Defining the species (`Species` class)

This provides the general features that are realised in the agents, either stochastically (e.g. initial body mass) and/or functional relationships with the environment (e.g. how SST affects energy expenditure). It has been named _species_ but could be considered a population depending on the context e.g. if there are parameters known down to a colony level, and potentially different from other colonies.

[Note `varDist` class is defined for a common interface in setting stochasticity, based on the `distributional` package]

 __Labels__ (`id`, `common_name`, `scientific_name`) these are used to identify the species in the simulation, and can be used to query the simulation results. They are not used in any functional way, but are useful for labelling outputs and queries.
 __Body mass__ (`body_mass_distr`) this is a distribution of the initial body mass of the agents, which can be defined as a `VarDist` object. This is used to initialise the agents with a body mass that reflects the population being simulated. The distribution can be defined using any of the supported distributions in `VarDist`, such as normal, log-normal, or gamma distributions.
 __Mortality Threshold__  (`mortality_thresh_distr`) defines thresholds where agents are considered to have died, based on their body mass.
 __Population Size__ (`pop_size`) this is a nominal size of the population being simulated, which can be used to optionally scale the results of the simulation. 
__Activity States__ (`activity_states`) this is a list of `ActivityState` objects, which define the different states that the agents can be in, such as foraging, resting, or flying. Each state has a name, a distribution of body mass loss, and a distribution of flight speed. The states can be defined with different distributions for different species, and can be used to model the behaviour of the agents in the simulation.
__Response to Environment__ (`driver_responses`) these are custom defined functions that relate species (and therefore agent) behaviour with regards their environment, as represented by the `Driver` class. These are a very flexible element of the simulation, so expanded upon below.

## Driver responses


# Defining the environment (`Driver` class)

# The basic unit (`Agent` class)

# Moving agents, running the simulation (`IBM` class)

# Querying the simulation, counterfactuals


# Installation 

`roamR` is not currently on CRAN - installation is direct from github. You can use devtools to install:

```{r, eval=FALSE}

devtools::install_github("....")
```


# References

* momentHMM
