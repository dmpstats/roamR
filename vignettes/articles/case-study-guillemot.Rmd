---
title: 'Case Study: guillemot Isle of May'
resource_files: images/roamR_schema.png
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
# install.packages("pak")
# pak::pkg_install("dmpstats/roamR")

library(roamR)
library(sf)
#library(stars)
library(tidyverse)
library(distributional)
library(stars)
```

# Overview
Here we use `{roamR}` to simulate the movement and energetics for a population of common guillemot (_Uria aalge_) on the Isle of May. For details on the `{roamR}` package, refer to the general guide (XX), with the general achitecture repeated here:

![{roamR} arhitecture](images/roamR_schema.png)


The simulations here cover the non-breeding season (some 9 months from X to X) under two broad scenarios:

* An environment free of Off-Shore Windfarms (OWFs) - nominally the status quo
* An environment with many synthetic OWF developments 

The overall intention is to quantify the effects of potential displacement from these developments, based on counter-factual comparisons of animal's condition under these scenarios. In keeping with the architecture of the `{roamR}` package, the following main components will be populated:

* __IBM general settings__ (`<ModelConfig>`) sundry high-level controls for the simulation, such as the number of agents, broad spatial boundaries, spatial projections, time-steps, start & finish dates.
* __Species-level information__ (`<Species>`) such as distributions governing initial bodymass, what behavioural states are possible, movement parameters, and how agents respond to their environment e.g.  avoidance of windfarms or landmass, costs associated with activity.
* __Drivers__ (`<Driver>`) descriptions/data that define the environment that agents may interact with or respond to e.g. sea surface temperatures, locations of windfarms, coastlines, prey fields etc.

The extent to which these can be populated will obviously vary, with the guillemot chosen here as a population that is relatively well studied. `{roamR}` is intentionally general and has substantial functionality that will not be used in a simulation. We will populate various elements of the simulation in turn, before turning to running the simulation and post-processing the results.


# Input data
As a relatively well-studied species/population, there are many `{roamR}` elements to populate. Mainly these are:

* Density maps
* SST
* Activity data
* Energetics
* Bodyweight
* Bodymass conversion

which will be a) described in detail and b) specified in `{roamR}` forms in the following sections. `{roamR}` can be run with very little data (an example of a more data sparse species is given in the test study XX), with the results being correspondingly less informative and stochastic.


## IBM configuration

The broad configuration of the IBM is specified via the function `ModelConfig()`.In the interest of speed, the example simulation here will not be large in terms of the number of agents to run - we'll opt for 10 agents (`n_agents`). The non-breeding season for these animals runs from approximately start of July for 9 months (`start_date`, `end_date`). We'll opt for a uniform 1km^2 spatial resolution (`x_delta`, `y_delta`) and have everything operate on the UTM 30N coordinate system (`ref_sys`). This will be the basis of ingesting and aligning the general spatial inputs. Note: the package currently requires all spatial inputs (e.g. density maps) to be provided in a common CRS projection ^[functionality to homogenise CRSs across spatial inputs during model initialization is expected to be implemented in `{roamR}` in the near future]. The `{sf}` package is generally used for dealing with spatial data (and the interlinked `{stars}` package for spatio-temporal).


```{r}
# Set UTM zone 30N
utm30 <- st_crs(32630)

```

Agent start and end locations (`start_sites`, `end_sites`) must be supplied as `sf` objects containing two required columns: `id` (a unique site identifier) and `prop` (the proportion of agents assigned to each site). In this example, we use the Isle of May as the sole starting location, specified by its geographic coordinates (longitude/latitude). Note that `end_sites` is currently ignored by the simulation, as the movement model assumes agents remain at their final locations once the simulation ends. As noted earlier, the site must be reprojected to the common UTM Zone 30N coordinate reference system.


```{r}
# location of colony in long/lat degrees - start/finish locations
isle_may <- st_sf(
  id = "Isle of May",
  prop = 1,
  geom = st_sfc(st_point(c(-2.5667, 56.1833))),
  crs = 4326) 

# re-project to UTM 30N
isle_may <- st_transform(isle_may, crs = utm30)

```


In terms of bounding the entire simulation spatially, we've opted for a bounding box from a previous study applied to this species [?REFERENCE]. Note this a hard boundary in terms of simulations - data outside this will have no influence. 

```{r}
# AoC in UTM. Exact figures come from a previous lat/lon example
AoC <- st_bbox(c(xmin = 178831, ymin = 5906535,  xmax = 1174762, ymax = 6783609), crs = st_crs(utm30))
```


Passing the above configuration inputs to `ModelConfig()` creates a `<ModelConfig>` object, which we assigned to `guill_ibm_config`:

```{r}

# IBM Settings - assume fixed for these simulations

guill_ibm_config <- ModelConfig(
  n_agents = 10,
  ref_sys = utm30,
  aoc_bbx = AoC, 
  delta_x = 1000,
  delta_y = 1000,
  delta_time = "1 day",
  start_date = date("2025-07-01"),
  end_date = date("2025-07-01") + 270, 
  start_sites = isle_may
)

class(guill_ibm_config)

```

## Driver information

Drivers define the environment that agents may interact with or respond, with
each driver being specified via the `Driver()` function. In this application to
the common guillemot, the following drivers are required - all provided as
spatio-temporal datacubes (rasters):

* Monthly species density surfaces, for both baseline and impacted scenarios
* Monthly energy intake maps (kJ/h), for both baseline and impacted scenarios
* Monthly average Sea Surface Temperature (SST) maps

`{roamR}` enforces a strict requirement that all input variables be accompanied
by appropriate measurement units. This ensures that all computations performed
during simulation are unit-aware, allowing for accurate operations and
conversions.

We begin by uploading these datacubes, assigning measurement units where they are missing.

 
```{r}
# driver spatial surfaces

spec_map <- readRDS("data/bioss_spec_map.rds") |> 
   mutate(density =  units::set_units(density, "counts"))

spec_imp_map <- readRDS("data/bioss_spec_imp_map.rds") |> 
   mutate(density =  units::set_units(density, "counts"))

intake_map <- readRDS("data/guill_energy_intake_map.rds")

imp_intake_map <- readRDS("data/guill_impacted_energy_intake_map.rds")

sst_map <- readRDS("data/bioss_sst_stars.rds") |> 
  mutate(sst =  units::set_units(sst, "degree_Celsius"))

```

Next we specify the corresponding drivers, and stored the as a list of `<Driver>` objects.

```{r}
# Set up IBM drivers 

dens_drv <- Driver(
  id = "dens",
  type = "resource",
  descr = "species dens map",
  stars_obj = spec_map
)

dens_imp_drv <- Driver(
  id = "dens_imp",
  type = "resource",
  descr = "species redist map",
  stars_obj = spec_imp_map
)

energy_drv <- Driver(
  id = "energy",
  type = "resource",
  descr = "energy map",
  stars_obj = intake_map
)

imp_energy_drv <- Driver(
  id = "imp_energy",
  type = "resource",
  descr = "energy impact map",
  stars_obj = imp_intake_map
)


sst_drv <- Driver(
  id = "sst",
  type = "habitat",
  descr = "Sea Surface Temperature",
  stars_obj = sst_map
)


# store as list for initialisation
guill_drivers <- list(
  dens = dens_drv,
  imp_dens = dens_imp_drv,
  energy = energy_drv,
  imp_energy = imp_energy_drv,
  sst = sst_drv
)
```


## Species information

Species-level information is defined using the `Species()` function, which
depends on a set of input objects. For clarity and modularity, these inputs
should be prepared and specified beforehand.

### States Profile

We begin by defining the behavioural states to include in the model. Each state
represents a specific activity, characterized by parameters such as energy
expenditure, time allocation, and movement speed.

States are created using the `State()` function. `{roamR}` supports flexible
specification of state properties, allowing the incorporation of stochastic
variation at both the population and individual (agent) level.

Here we include 4 states:
* flight
* diving
* active on water (swimming)
* inactive on water (resting)


We start with the flight state. For the current simulation, we assume the
energetic cost of flying for each agent varies throughout the simulation,
following a Normal distribution with mean `507.6 kJ/h` and standard deviation of
`237.6 kJ/h`. On the other hand, the average speed of each agent is fixed over
the simulation, with agents speeds drawn from a uniform distribution, as
specified below.

```{r}
flight_cost_fn <- function(mean, sd){
  e <- rnorm(1, mean, sd)
  (max(e, 1)) |>
    units::set_units("kJ/h")
}

flight <- State(
  id = "flight", 
  energy_cost = VarFn(
    flight_cost_fn, 
    args_spec = list(mean = 507.6, sd = 237.6), 
    units = "kJ/hour"
    ), 
  time_budget = VarDist(0.056, "hours/day"), 
  speed = VarDist(dist_uniform(10, 20), "m/s")
)

```


The diving activity.

```{r}
# 
# dive_cost_fn <- function(t_dive, species){
# 
#   x <- units::drop_units(t_dive)
# 
#   rand_par <- generate(species@states_profile$dive@energy_cost, 1) |>
#     units::drop_units()
# 
#   (max(rand_par*sum(1-exp(-x/1.23))/sum(x)*60, 1)) |>
#     units::set_units("kJ/h")
# 
# }
# 
#   dive = State(
#     id = "diving",
#     energy_cost = VarDist(dist_normal(3.71, 1.3), units = NULL), # from spreadsheet
#     time_budget = VarDist(dist_degenerate(3.11), "hours/day"), # roughly based on Lila's summaries
#     speed = VarDist(dist_uniform(0, 1), "m/s") # placeholder, not very relevant
#   )


```


### Driver Responses






# Setting up and running the IBM

## Initialisation


* Agents!


## Running the simulation



# Digesting the results













