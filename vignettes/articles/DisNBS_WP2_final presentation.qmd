---
# title: "DisNBS WP2"
# author: "DMP"
execute:
  echo: true
editor: visual
format:
  revealjs: 
    theme: dark
    include-in-header:
      - file: zoom-in-out.html
---

# DisNBS work-package 2

Distribution of Seabirds in the Non-Breeding Season

## Outline {.scrollable}

- Project overview/recap
- `roamR` 
  - package structure
  - workflow
  - delve into components
- Break
- Case study: Guillemot Isle of May
  - IBM setup and population
  - small scale run
  - examination of outputs
- Questions


## The DisNBS IBM 

For WP2:

- Seeking to develop an IBM that can explore impact scenarios for UK seabirds in the non-breeding season
- A complement to seaBORD, which is an IBM restricted to the breeding season
- Should be general as possible, so that it can be applied to a range of species and scenarios
- Note: Species can have markedly different levels of information

## WP1 design
The IBM components were established in work package 1

![](images/WP1_schema.png)

<!-- ================================================================================================ -->

## WP1 design implementation

- The IBM design was implemented in R (open-source, transparent)
- It is a package, which is more robust and maintainable than a series of scripts
- Is customisable where needed, with tools to assist this
- It formalises many of the repeated elements in an IBM, leaving focus on clearly defined customisable components i.e. mainly how species interact with the environment


# Package `roamR`

R package of tools and framework to support IBMs

## `roamR` solution

-   Framework and toolset - forces an abstract structure on the problem

::: {.incremental}
-   Emphasis on generality - the data and mechanics of simulation for different species can be markedly different 
-   Standardises inputs/outputs and performs checks
- Effort can be focused on how things relate to one another
- Removes issues with continually rewriting similar IBM functionality
:::

## Architecture overview

We've created an IBM structure that ought to cover all contingencies, which consists of:

::: {.incremental}
- The simulation engine and wrapper
- The species
- The environment
- The agents
- Layers of stochasticity 
- [perturbation, matched runs]
- Post-processing
::: 

## Architecture overview: wrapper

The simulation engine and wrapper - high-level controls:

::: {.incremental}
- the number of agents, 
- spatial/temporal boundaries e.g. a bounding box, simulation period
- fundamental spatial coordinate system
- agent movement methods
- parallelisation
:::

## Architecture overview: species

"Species" is the population being simulated i.e. can be a colony, which will have population level properties e.g.:

::: {.incremental}
- distributions of initial body mass, flying speeds
- behavioural states (e.g. foraging, resting, flying)
- functional responses to the environment (e.g. move towards prey, avoid OWF)
- energetics of behavoural states
:::

## Architecture overview: environment

The spatiotemporal descriptions of the agent’s environment within the simulation frame e.g. 

  - natural boundaries (coast), 
  - the Sea Surface Temperature (SST) over time, 
  - man-made structures (e.g. OWF)
  - prey fields, energy maps
  
## Architecture overview: environment

Note large scale influences are accommodated through vector fields:

![](images/vectorplot_small.png)

Note `roamR` will calculate these from inputs where required.

## Architecture overview: agent

The agents: 

- the basic simulation element 

::: {.incremental}
- largely defined from higher components 
- are moved through and respond to their environment
- have properties monitored e.g. net energy intake, location, behavioural states etc
- the basis of monitoring the simulation and any counterfactuals
:::

## Architecture
The `roamR` design scheme

![](images/roamR_schema.png)


## Movement models

Two agent movement methods are supported with complexity/data requirements.

- "Density informed" uses density information for preferred locations, coupled with activity budgets and basic speed information to give travel paths.
- Correlated Random Walk (CRW) stochastic direction and steps, informed by environment.

## Movement models - density informed

The process is:

::: {.incremental}
1.	Species’ density information gives stochasti destinations i.e. high density areas are relatively more likely to be travelled to
2.	Determine a feasible path (e.g. OWF, coastlines, bounding box)
3.	Travel on the path is constrained WRT speed properties and activity budget
4.	Iteratively regenerate destinations and paths
::: 

## Movement models - Correlated Random Walk (CRW)

- Iterative generation of stochastic movement directions, then making a stochastic step. 
- can impose dependencies to provide a directed random walk, and when related to local drivers, be functionally responsive to the environment. 

![](images/crw.png)

## Movement models - Correlated Random Walk (CRW)

The process is primarily:

::: {.incremental}
1.	Select a stochastic movement direction (wrapped Normal in roamR - parameters can relate to enviroment)
2.	Select a stochastic step length based on a distribution (e.g. gamma).
3.	Iterate.
:::

Can be state dependent e.g. flying (fast and directed), resting (stationary) - depending on the species definition.

## States: activity budgets and rebalancing {.scrollable}

- daily activity budget (time spent in each state) is not fixed, and can be responsive to environment and agent condition. 
- `roamR` allows a “state rebalancing” on a daily basis - agents will attempt to compensate for poor foraging by increasing the amount of time dedicated to feeding:

::: {.incremental}
  - state distribution can be made dependent the previous day’s net energy intake 
  - Balancing is not be exact, as the daily energy intake achieved is subject to stochastic elements.
  - The changes in activity to seek energy balance are primarily through increasing/decreasing feeding and resting times.
  - Agents are constrained to rest overnight, based on day length calculations for the agent’s location and time.
:::

<!-- ================================================================================================ -->

# `roamR` workflow

## Workflow {.scrollable}

::: {.incremental}
1. ___Configure simulation___ at a high-level, including the spatial and temporal boundaries, projections, number of agents etc.
1. ___Define species___,  initial body mass distributions, speed distributions, activity states and their energetic implications, functional relationships between the species and the environment e.g. how SST affects energy, how OWFs influence movement/distribution.
1. ___Define environment___, essentially anything spatio-temporal that the animals are thought to respond to: coastline, man-made structures (e.g. OWF), prey distributions, SST, bathymetry etc.
1. ___Combine components___ into an IBM object.
1. ___Run simulation___, create agents, parallelises calculations, move agents through the environment, records properties over time.
1. ___Alter simulation___ elements to reflect a perturbation (presence of OWF).
1. ___Re-run___ simulate withperturbation.
1. ___Query simulated animals___, counterfactuals based on within-agent comparisons over perturbation scenarios.
::: 



<!-- ================================================================================================ -->

# Break

<!-- ================================================================================================ -->

# Case study

Guillemot Isle of May

## Overview

- Isle of May Guillemots
- A full non-breeding season simulation (set to 9 months)
- A single perturbation scenario, where many synthetic OWFs are placed in the simulation area

## Overview
The Area of Calculation (AoC) and synthetic OWF

![](images/guill_OWF_scenario.png)

## Simulation level config

```{r}
#| eval: false
# Set UTM zone 30N
utm30 <- st_crs(32630)

# location of colony in long/lat degrees - start/finish locations
isle_may <- st_sf(
  id = "Isle of May",
  prop = 1,
  geom = st_sfc(st_point(c(-2.5667, 56.1833))),
  crs = 4326) 

# re-project to UTM 30N
isle_may <- st_transform(isle_may, crs = utm30)

# AoC in UTM. Exact figures come from a previous lat/lon example
AoC <- st_bbox(c(xmin = 178831, ymin = 5906535,  xmax = 1174762, ymax = 6783609), crs = st_crs(utm30))
```

## Simulation level config

Use `ModelConfig()` to create `<ModelConfig>` object, called `guill_ibm_config`:

```{r}
#| eval: false
  
# IBM Settings - assume fixed for these simulations

guill_ibm_config <- ModelConfig(
  n_agents = 10,
  ref_sys = utm30,
  aoc_bbx = AoC, 
  delta_x = 1000,
  delta_y = 1000,
  delta_time = "1 day",
  start_date = date("2025-07-01"),
  end_date = date("2025-07-01") + 270, 
  start_sites = isle_may
)

class(guill_ibm_config)

```

## Input data sources {.scrollable}

Data for defining the environment - these are all spatiotemporal datacubes ($x$ & $y$ at $t$)

```{r}
#| eval: false

# Set up IBM drivers 

dens_drv <- Driver(
  id = "dens",
  type = "resource",
  descr = "species dens map",
  stars_obj = spec_map,
  obj_active = "stars"
)

dens_imp_drv <- Driver(
  id = "dens_imp",
  type = "resource",
  descr = "species redist map",
  stars_obj = spec_imp_map,
  obj_active = "stars"
)

energy_drv <- Driver(
  id = "energy",
  type = "resource",
  descr = "energy map",
  stars_obj = intake_map,
  obj_active = "stars"
)

imp_energy_drv <- Driver(
  id = "imp_energy",
  type = "resource",
  descr = "energy impact map",
  stars_obj = imp_intake_map,
  obj_active = "stars"
)


sst_drv <- Driver(
  id = "sst",
  type = "habitat",
  descr = "Sea Surface Temperature",
  stars_obj = sst_map,
  obj_active = "stars"
)


# store as list for initialisation
guill_drivers <- list(
  dens = dens_drv,
  imp_dens = dens_imp_drv,
  energy = energy_drv,
  imp_energy = imp_energy_drv,
  sst = sst_drv
)
```

## Define species {.scrollable}
Species specific functions (energetics, environmental) for example:

```{r}
#| eval: false

# user-defined function returning the energy cost of flying
flight_cost_fn <- function(mean, sd){
  e <- rnorm(1, mean, sd)
  (max(e, 1)) |>
    units::set_units("kJ/h")
}

flight <- State(
  id = "flight", 
  energy_cost = VarFn(
    flight_cost_fn, 
    args_spec = list(mean = 507.6, sd = 237.6), 
    units = "kJ/hour"
    ), 
  time_budget = VarDist(0.056, "hours/day"), 
  speed = VarDist(dist_uniform(10, 20), "m/s")
)

```


## Define species
Extended to all states:

```{r}
#| eval: false

# define costing function
dive_cost_fn <- function(t_dive, alpha_mean, alpha_sd){
  alpha <- rnorm(1, alpha_mean, alpha_sd)
  (max(alpha*sum(1-exp(-t_dive/1.23))/sum(t_dive)*60, 1)) |>
    units::set_units("kJ/h")
}

# Construct <State> object
dive <- State(
  id = "diving", 
  energy_cost = VarFn(
    dive_cost_fn, 
    args_spec = list(t_dive = 1.05, alpha_mean = 3.71, alpha_sd = 1.3), 
    units = "kJ/hour"
    ), 
  time_budget = VarDist(3.11, "hours/day"), 
  speed = VarDist(dist_uniform(0, 1), "m/s")
)

```

## Define species
Extended to all states:

```{r}
#| eval: false

active_water_cost_fn <- function(sst, int_mean, int_sd){
  int <- rnorm(1, int_mean, int_sd)
  (max(int-(2.75*sst), 1)) |>
    units::set_units("kJ/h")
}


# Construct <State> object
active <- State(
  id = "active_on_water", 
  energy_cost = VarFn(
    active_water_cost_fn, 
    args_spec = list(sst = "driver", int_mean = 113, int_sd = 22), 
    units = "kJ/hour"
  ), 
  time_budget = VarDist(10.5, "hours/day"), 
  speed = VarDist(dist_uniform(0, 1), "m/s")
)
```

## Define species
Extended to all states:

```{r}
#| eval: false

inactive_water_cost_fn <- function(sst, int_mean, int_sd){
  int <- rnorm(1, int_mean, int_sd)
  (max(int-(2.75*sst), 1)) |>
    units::set_units("kJ/h")
}


inactive <- State(
  id = "inactive_on_water", 
  energy_cost = VarFn(
    active_water_cost_fn, 
    args_spec = list(sst = "driver", int_mean = 72.2, int_sd = 22), 
    units = "kJ/hour"
  ), 
  time_budget = VarDist(10.3, "hours/day"), 
  speed = VarDist(dist_uniform(0, 1), "m/s")
)

```

## Define species
State definitions are combined to pass into the species definition:

```{r}
#| eval: false

guill_states <- list(
  flight = flight,
  dive = dive,
  active = active,
  inactive = inactive
)
```

## Define species {.scrollable}
Define interactions between the species and environment (spatiotemporal drivers), for example:

```{r}
#| eval: false

resp_dens <- DriverResponse(
  driver_id = "dens",
  movement = MoveInfluence(
    prob = VarDist(distributional::dist_degenerate(1)),
    type = "attraction",
    mode = "cell-value",
    sim_stage = "bsln"
  )
)

resp_imp_dens <- DriverResponse(
  driver_id = "dens_imp",
  movement = MoveInfluence(
    prob = VarDist(distributional::dist_normal(0.67, sd = 0.061)),
    type = "attraction",
    mode = "cell-value",
    sim_stage = "imp"
  )
)
```

## Define species {.scrollable}

Other species level definitions - noting these populate agents:

```{r}
#| eval: false
  
guill <- Species(
  id = "guill",
  common_name = "guillemot",
  scientific_name = "Uria Aalge",
  body_mass_distr = VarDist(dist_normal(mean = 929, sd = 56), "g"),
  energy_to_mass_distr = VarDist(0.072, "g/kJ"),
  states_profile = guill_states,
  driver_responses = list(resp_dens, resp_imp_dens)
)

```

## Prep the IBM
Combine all the components (config, species, environment/drivers), perform checks and __create agents__

```{r}
#| eval: false

guill_ibm <- rmr_initiate(
  model_config = guill_ibm_config,
  species = guill,
  drivers = guill_drivers
)
```

## Run `roamR`  {.scrollable}

Supports parallelisation. Moves all agents through the simulated environment for the specified time, records states in agent __history__

```{r}
#| eval: false
  
plan(multisession, workers = future::availableCores() - 2)

guill_results <- run_disnbs(
  ibm = guill_ibm,
  run_scen = "baseline-and-impact", 
  dens_id = "dens", 
  intake_id = "energy", 
  imp_dens_id = "dens_imp", 
  imp_intake_id = "imp_energy", 
  feed_state_id = "diving", 
  roost_state_id = "inactive_on_water", 
  feed_avg_net_energy = units::set_units(422, "kJ/h"), 
  target_energy = units::set_units(1, "kJ"), 
  smooth_body_mass = bm_smooth_opts(time_bw = "7 days"), 
  waypnts_res = 1000, 
  seed = 1990
)


```

## Output overview

- Ultimately creates a list of agents, with detailed history of their simulations, including:
  - body mass, 
  - energy intake, 
  - activity states, 
  - movement paths, 
  - and more.

These can all be queried with minimal effort.  

## Specific results - tracks


![](images/tracks.png)


## Specific results - bodymass

![](images/bodymass.png)

## Specific results - bodymass
![](images/agent_wts.png)

## Specific results - bodymass
![](images/diff_plot.png)


## `roamR` run
....

# Utility

## Use of counterfactals

Quantification of the impact of the perturbation can be done on any of the defined agent condition (and/or history), but likely to be differences in:

- Cumulative net energy
- Season-end body mass or mass change
- Distributions of activity/behavioural states
- Minimum body-mass over the season
- relatedly) Mortality

## Use of counterfactals

- These are not single values, but distributions representing the variability in the simulated populations
- Directly informative at a population level, and tangible for down-stream calculations. For example, passed to Population Viability Analyses (PVAs) where counterfactuals may use:

  - Increases in mortality/proportional reductions in population size
  - Relationships between body mass and reproductive success, to alter PVA demographic parameters


## User Interface

- Currently use of `roamR` is through markdown template i.e. a series of descriptions and code exemplars that are modified for user needs
- The package is well-formed, so would form a solid basis for a shiny interface


<!-- ================================================================================================ -->

# Questions?
