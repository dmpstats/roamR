{
  "hash": "d9f703a692025f12fb61b944efccec5e",
  "result": {
    "engine": "knitr",
    "markdown": "---\n# title: \"DisNBS WP2\"\n# author: \"DMP\"\nexecute:\n  echo: true\neditor: visual\nformat:\n  revealjs: \n    theme: dark\n    include-in-header:\n      - file: zoom-in-out.html\n---\n\n\n\n# DisNBS work-package 2\n\nDistribution of Seabirds in the Non-Breeding Season\n\n## Outline {.scrollable}\n\n-   Project overview/recap\n-   `roamR`\n    -   package structure\n    -   workflow\n    -   delve into components\n-   Break\n-   Case study: Guillemot Isle of May\n    -   IBM setup and population\n    -   small scale run\n    -   examination of outputs\n-   Questions\n\n## The DisNBS IBM\n\nFor WP2:\n\n-   Seeking to develop an IBM that can explore impact scenarios for UK seabirds in the non-breeding season\n-   A complement to seaBORD, which is an IBM restricted to the breeding season\n-   Should be general as possible, so that it can be applied to a range of species and scenarios\n-   Note: Species can have markedly different levels of information\n\n## WP1 design\n\nThe IBM components were established in work package 1\n\n![](images/WP1_schema.png)\n\n<!-- ================================================================================================ -->\n\n## WP1 design implementation\n\n-   The IBM design was implemented in R (open-source, transparent)\n-   It is a package, which is more robust and maintainable than a series of scripts\n-   Is customisable where needed, with tools to assist this\n-   It formalises many of the repeated elements in an IBM, leaving focus on clearly defined customisable components i.e. mainly how species interact with the environment\n\n# Package `roamR`\n\nR package of tools and framework to support IBMs\n\n## `roamR` solution\n\n-   Framework and toolset - forces an abstract structure on the problem\n\n::: incremental\n-   Emphasis on generality - the data and mechanics of simulation for different species can be markedly different\n-   Standardises inputs/outputs and performs checks\n-   Effort can be focused on how things relate to one another\n-   Removes issues with continually rewriting similar IBM functionality\n:::\n\n## Architecture overview\n\nWe've created an IBM structure that ought to cover all contingencies, which consists of:\n\n::: incremental\n-   The simulation engine and wrapper\n-   The species\n-   The environment\n-   The agents\n-   Layers of stochasticity\n-   \\[perturbation, matched runs\\]\n-   Post-processing\n:::\n\n## Architecture overview: wrapper\n\nThe simulation engine and wrapper - high-level controls:\n\n::: incremental\n-   the number of agents,\n-   spatial/temporal boundaries e.g. a bounding box, simulation period\n-   fundamental spatial coordinate system\n-   agent movement methods\n-   parallelisation\n:::\n\n## Architecture overview: species\n\n\"Species\" is the population being simulated i.e. can be a colony, which will have population level properties e.g.:\n\n::: incremental\n-   distributions of initial body mass, flying speeds\n-   behavioural states (e.g. foraging, resting, flying)\n-   functional responses to the environment (e.g. move towards prey, avoid OWF)\n-   energetics of behavoural states\n:::\n\n## Architecture overview: environment\n\nThe spatiotemporal descriptions of the agent’s environment within the simulation frame e.g.\n\n-   natural boundaries (coast),\n-   the Sea Surface Temperature (SST) over time,\n-   man-made structures (e.g. OWF)\n-   prey fields, energy maps\n\n## Architecture overview: environment\n\nNote large scale influences are accommodated through vector fields:\n\n![](images/vectorplot_small.png)\n\nNote `roamR` will calculate these from inputs where required.\n\n## Architecture overview: agent\n\nThe agents:\n\n-   the basic simulation element\n\n::: incremental\n-   largely defined from higher components\n-   are moved through and respond to their environment\n-   have properties monitored e.g. net energy intake, location, behavioural states etc\n-   the basis of monitoring the simulation and any counterfactuals\n:::\n\n## Architecture\n\nThe `roamR` design scheme\n\n![](images/roamR_schema.png)\n\n## Movement models\n\nTwo agent movement methods are supported with complexity/data requirements.\n\n-   \"Density informed\" uses density information for preferred locations, coupled with activity budgets and basic speed information to give travel paths.\n-   Correlated Random Walk (CRW) stochastic direction and steps, informed by environment.\n\n## Movement models - density informed\n\nThe process is:\n\n::: incremental\n1.  Species’ density information gives stochasti destinations i.e. high density areas are relatively more likely to be travelled to\n2.  Determine a feasible path (e.g. OWF, coastlines, bounding box)\n3.  Travel on the path is constrained WRT speed properties and activity budget\n4.  Iteratively regenerate destinations and paths\n:::\n\n## Movement models - Correlated Random Walk (CRW)\n\n-   Iterative generation of stochastic movement directions, then making a stochastic step.\n-   can impose dependencies to provide a directed random walk, and when related to local drivers, be functionally responsive to the environment.\n\n![](images/crw.png)\n\n## Movement models - Correlated Random Walk (CRW)\n\nThe process is primarily:\n\n::: incremental\n1.  Select a stochastic movement direction (wrapped Normal in roamR - parameters can relate to enviroment)\n2.  Select a stochastic step length based on a distribution (e.g. gamma).\n3.  Iterate.\n:::\n\nCan be state dependent e.g. flying (fast and directed), resting (stationary) - depending on the species definition.\n\n## States: activity budgets and rebalancing {.scrollable}\n\n-   daily activity budget (time spent in each state) is not fixed, and can be responsive to environment and agent condition.\n-   `roamR` allows a “state rebalancing” on a daily basis - agents will attempt to compensate for poor foraging by increasing the amount of time dedicated to feeding:\n\n::: incremental\n-   state distribution can be made dependent the previous day’s net energy intake\n-   Balancing is not be exact, as the daily energy intake achieved is subject to stochastic elements.\n-   The changes in activity to seek energy balance are primarily through increasing/decreasing feeding and resting times.\n-   Agents are constrained to rest overnight, based on day length calculations for the agent’s location and time.\n:::\n\n<!-- ================================================================================================ -->\n\n# `roamR` workflow\n\n## Workflow {.scrollable}\n\n::: incremental\n1.  ***Configure simulation*** at a high-level, including the spatial and temporal boundaries, projections, number of agents etc.\n2.  ***Define species***, initial body mass distributions, speed distributions, activity states and their energetic implications, functional relationships between the species and the environment e.g. how SST affects energy, how OWFs influence movement/distribution.\n3.  ***Define environment***, essentially anything spatio-temporal that the animals are thought to respond to: coastline, man-made structures (e.g. OWF), prey distributions, SST, bathymetry etc.\n4.  ***Combine components*** into an IBM object.\n5.  ***Run simulation***, create agents, parallelises calculations, move agents through the environment, records properties over time.\n6.  ***Alter simulation*** elements to reflect a perturbation (presence of OWF).\n7.  ***Re-run*** simulate withperturbation.\n8.  ***Query simulated animals***, counterfactuals based on within-agent comparisons over perturbation scenarios.\n:::\n\n<!-- ================================================================================================ -->\n\n# Break\n\n<!-- ================================================================================================ -->\n\n# Case study\n\nGuillemot Isle of May\n\n## Overview\n\n-   Isle of May Guillemots\n-   A full non-breeding season simulation (set to 9 months)\n-   A single perturbation scenario, where many synthetic OWFs are placed in the simulation area\n\n## Overview\n\nThe Area of Calculation (AoC) and synthetic OWF\n\n![](images/guill_OWF_scenario.png)\n\n## Simulation level config\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set UTM zone 30N\nutm30 <- st_crs(32630)\n\n# location of colony in long/lat degrees - start/finish locations\nisle_may <- st_sf(\n  id = \"Isle of May\",\n  prop = 1,\n  geom = st_sfc(st_point(c(-2.5667, 56.1833))),\n  crs = 4326) \n\n# re-project to UTM 30N\nisle_may <- st_transform(isle_may, crs = utm30)\n\n# AoC in UTM. Exact figures come from a previous lat/lon example\nAoC <- st_bbox(c(xmin = 178831, ymin = 5906535,  xmax = 1174762, ymax = 6783609), crs = st_crs(utm30))\n```\n:::\n\n\n\n## Simulation level config\n\nUse `ModelConfig()` to create `<ModelConfig>` object, called `guill_ibm_config`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# IBM Settings - assume fixed for these simulations\n\nguill_ibm_config <- ModelConfig(\n  n_agents = 10,\n  ref_sys = utm30,\n  aoc_bbx = AoC, \n  delta_x = 1000,\n  delta_y = 1000,\n  delta_time = \"1 day\",\n  start_date = date(\"2025-07-01\"),\n  end_date = date(\"2025-07-01\") + 270, \n  start_sites = isle_may\n)\n\nclass(guill_ibm_config)\n```\n:::\n\n\n\n## Input data sources {.scrollable}\n\nData for defining the environment - these are all spatiotemporal datacubes ($x$ & $y$ at $t$)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up IBM drivers \n\ndens_drv <- Driver(\n  id = \"dens\",\n  type = \"resource\",\n  descr = \"species dens map\",\n  stars_obj = spec_map,\n  obj_active = \"stars\"\n)\n\ndens_imp_drv <- Driver(\n  id = \"dens_imp\",\n  type = \"resource\",\n  descr = \"species redist map\",\n  stars_obj = spec_imp_map,\n  obj_active = \"stars\"\n)\n\nenergy_drv <- Driver(\n  id = \"energy\",\n  type = \"resource\",\n  descr = \"energy map\",\n  stars_obj = intake_map,\n  obj_active = \"stars\"\n)\n\nimp_energy_drv <- Driver(\n  id = \"imp_energy\",\n  type = \"resource\",\n  descr = \"energy impact map\",\n  stars_obj = imp_intake_map,\n  obj_active = \"stars\"\n)\n\n\nsst_drv <- Driver(\n  id = \"sst\",\n  type = \"habitat\",\n  descr = \"Sea Surface Temperature\",\n  stars_obj = sst_map,\n  obj_active = \"stars\"\n)\n\n\n# store as list for initialisation\nguill_drivers <- list(\n  dens = dens_drv,\n  imp_dens = dens_imp_drv,\n  energy = energy_drv,\n  imp_energy = imp_energy_drv,\n  sst = sst_drv\n)\n```\n:::\n\n\n\n## Define species {.scrollable}\n\nSpecies specific functions (energetics, environmental) for example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# user-defined function returning the energy cost of flying\nflight_cost_fn <- function(mean, sd){\n  e <- rnorm(1, mean, sd)\n  (max(e, 1)) |>\n    units::set_units(\"kJ/h\")\n}\n\nflight <- State(\n  id = \"flight\", \n  energy_cost = VarFn(\n    flight_cost_fn, \n    args_spec = list(mean = 507.6, sd = 237.6), \n    units = \"kJ/hour\"\n    ), \n  time_budget = VarDist(0.056, \"hours/day\"), \n  speed = VarDist(dist_uniform(10, 20), \"m/s\")\n)\n```\n:::\n\n\n\n## Define species\n\nExtended to all states:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define costing function\ndive_cost_fn <- function(t_dive, alpha_mean, alpha_sd){\n  alpha <- rnorm(1, alpha_mean, alpha_sd)\n  (max(alpha*sum(1-exp(-t_dive/1.23))/sum(t_dive)*60, 1)) |>\n    units::set_units(\"kJ/h\")\n}\n\n# Construct <State> object\ndive <- State(\n  id = \"diving\", \n  energy_cost = VarFn(\n    dive_cost_fn, \n    args_spec = list(t_dive = 1.05, alpha_mean = 3.71, alpha_sd = 1.3), \n    units = \"kJ/hour\"\n    ), \n  time_budget = VarDist(3.11, \"hours/day\"), \n  speed = VarDist(dist_uniform(0, 1), \"m/s\")\n)\n```\n:::\n\n\n\n## Define species\n\nExtended to all states:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactive_water_cost_fn <- function(sst, int_mean, int_sd){\n  int <- rnorm(1, int_mean, int_sd)\n  (max(int-(2.75*sst), 1)) |>\n    units::set_units(\"kJ/h\")\n}\n\n\n# Construct <State> object\nactive <- State(\n  id = \"active_on_water\", \n  energy_cost = VarFn(\n    active_water_cost_fn, \n    args_spec = list(sst = \"driver\", int_mean = 113, int_sd = 22), \n    units = \"kJ/hour\"\n  ), \n  time_budget = VarDist(10.5, \"hours/day\"), \n  speed = VarDist(dist_uniform(0, 1), \"m/s\")\n)\n```\n:::\n\n\n\n## Define species\n\nExtended to all states:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninactive_water_cost_fn <- function(sst, int_mean, int_sd){\n  int <- rnorm(1, int_mean, int_sd)\n  (max(int-(2.75*sst), 1)) |>\n    units::set_units(\"kJ/h\")\n}\n\n\ninactive <- State(\n  id = \"inactive_on_water\", \n  energy_cost = VarFn(\n    active_water_cost_fn, \n    args_spec = list(sst = \"driver\", int_mean = 72.2, int_sd = 22), \n    units = \"kJ/hour\"\n  ), \n  time_budget = VarDist(10.3, \"hours/day\"), \n  speed = VarDist(dist_uniform(0, 1), \"m/s\")\n)\n```\n:::\n\n\n\n## Define species\n\nState definitions are combined to pass into the species definition:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nguill_states <- list(\n  flight = flight,\n  dive = dive,\n  active = active,\n  inactive = inactive\n)\n```\n:::\n\n\n\n## Define species {.scrollable}\n\nDefine interactions between the species and environment (spatiotemporal drivers), for example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp_dens <- DriverResponse(\n  driver_id = \"dens\",\n  movement = MoveInfluence(\n    prob = VarDist(distributional::dist_degenerate(1)),\n    type = \"attraction\",\n    mode = \"cell-value\",\n    sim_stage = \"bsln\"\n  )\n)\n\nresp_imp_dens <- DriverResponse(\n  driver_id = \"dens_imp\",\n  movement = MoveInfluence(\n    prob = VarDist(distributional::dist_normal(0.67, sd = 0.061)),\n    type = \"attraction\",\n    mode = \"cell-value\",\n    sim_stage = \"imp\"\n  )\n)\n```\n:::\n\n\n\n## Define species {.scrollable}\n\nOther species level definitions - noting these populate agents:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nguill <- Species(\n  id = \"guill\",\n  common_name = \"guillemot\",\n  scientific_name = \"Uria Aalge\",\n  body_mass_distr = VarDist(dist_normal(mean = 929, sd = 56), \"g\"),\n  energy_to_mass_distr = VarDist(0.072, \"g/kJ\"),\n  states_profile = guill_states,\n  driver_responses = list(resp_dens, resp_imp_dens)\n)\n```\n:::\n\n\n\n## Prep the IBM\n\nCombine all the components (config, species, environment/drivers), perform checks and **create agents**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nguill_ibm <- rmr_initiate(\n  model_config = guill_ibm_config,\n  species = guill,\n  drivers = guill_drivers\n)\n```\n:::\n\n\n\n## Run `roamR` {.scrollable}\n\nSupports parallelisation. Moves all agents through the simulated environment for the specified time, records states in agent **history**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplan(multisession, workers = future::availableCores() - 2)\n\nguill_results <- run_disnbs(\n  ibm = guill_ibm,\n  run_scen = \"baseline-and-impact\", \n  dens_id = \"dens\", \n  intake_id = \"energy\", \n  imp_dens_id = \"dens_imp\", \n  imp_intake_id = \"imp_energy\", \n  feed_state_id = \"diving\", \n  roost_state_id = \"inactive_on_water\", \n  feed_avg_net_energy = units::set_units(422, \"kJ/h\"), \n  target_energy = units::set_units(1, \"kJ\"), \n  smooth_body_mass = bm_smooth_opts(time_bw = \"7 days\"), \n  waypnts_res = 1000, \n  seed = 1990\n)\n```\n:::\n\n\n\n## Output overview\n\n-   Ultimately creates a list of agents, with detailed history of their simulations, including:\n    -   body mass,\n    -   energy intake,\n    -   activity states,\n    -   movement paths,\n    -   and more.\n\nThese can all be queried with minimal effort.\n\n## Specific results - tracks\n\n![](images/tracks.png)\n\n## Specific results - bodymass\n\n![](images/bodymass.png)\n\n## Specific results - bodymass\n\n![](images/agent_wts.png)\n\n## Specific results - bodymass\n\n![](images/diff_plot.png)\n\n## `roamR` run\n\n....\n\n# Utility\n\n## Use of counterfactals\n\nQuantification of the impact of the perturbation can be done on any of the defined agent condition (and/or history), but likely to be differences in:\n\n-   Cumulative net energy\n-   Season-end body mass or mass change\n-   Distributions of activity/behavioural states\n-   Minimum body-mass over the season\n-   relatedly) Mortality\n\n## Use of counterfactals\n\n-   These are not single values, but distributions representing the variability in the simulated populations\n\n-   Directly informative at a population level, and tangible for down-stream calculations. For example, passed to Population Viability Analyses (PVAs) where counterfactuals may use:\n\n    -   Increases in mortality/proportional reductions in population size\n    -   Relationships between body mass and reproductive success, to alter PVA demographic parameters\n\n## User Interface\n\n-   Currently use of `roamR` is through markdown template i.e. a series of descriptions and code exemplars that are modified for user needs\n-   The package is well-formed, so would form a solid basis for a shiny interface\n\n<!-- ================================================================================================ -->\n\n# Questions?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}