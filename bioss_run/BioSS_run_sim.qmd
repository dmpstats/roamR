---
title: "bioss_run_sim"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
---

## Setting up the IBM runs

Parallelisation, counter-factuals

## Initialise the IBM

Input data, species & model configurations etc


### Spatio-temporal inputs

Species, conspecifics and SST. Pre-parpared (clipped to AoC and projected to UTM30).

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| output: false

library(tidyverse)
library(roamR)
library(stars)
library(sf)
library(distributional)

# UTM zone 30N
utm30 <- st_crs(32630)

# AoC in UTM. Exact figures come from a previous lat/lon example
AoC <- st_bbox(c(xmin = 178831, ymin = 5906535,  xmax = 1174762, ymax = 6783609), crs = st_crs(utm30))

# Input data layers -----------------------------------------------------------------------------------------------
# datacubes: density, lat/lon/, month
spec_map <- readRDS("data/bioss_spec_map.rds")

conspec_map <- readRDS("data/bioss_conspec_map.rds") 

spec_imp_map <- readRDS("data/bioss_spec_imp_map.rds") 

conspec_imp_map <- readRDS("data/bioss_conspec_imp_map.rds") 

sst <- readRDS("data/bioss_sst_stars.rds")



```

Put these in as `roamR` drivers. Exclude conspecifics for dev.


```{r}
# Set up IBM drivers ----------------------------------------------------------------------------------------------

sst_drv <- Driver(
  id = "sst",
  type = "habitat",
  descr = "Sea Surface Temperature",
  stars_obj = sst
)


dens_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "species dens map",
  stars_obj = spec_map
)

dens_imp_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "species redist map",
  stars_obj = spec_imp_map
)

consp_drv <- Driver(
  id = "consp_dens",
  type = "impact",
  descr = "conspecific dens map",
  stars_obj = conspec_map
)

consp_imp_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "consp redist map",
  stars_obj = conspec_imp_map
)

# store as list for initialisation
guill_drivers <- list(
  sst = sst_drv,
  dens = dens_drv,
  consp = consp_drv
  # ,
  # dens_imp = dens_imp_drv,
  # consp_imp = consp_imp_drv
)
```

Blank at this point.

```{r}

# Response to drivers  -------------------------------------------------

driver_resp <- list()
```

### Species and model configurations

State specs: Of direct interest here, are the uncertainties around the energetics calculations.Currently these are used to generate stochastic values for each of the agents.


```{r}
# States specification -------------------------------------------------

states <- list(
  flight = State(
    id = "flight",
    energy_cost = VarDist(dist_normal(507.6, 237.6), units = "kJ/hour"), # vals from excel sheet. Normal may not be adequate (some good chance of <zero) - there is a catch for this
    time_budget = VarDist(dist_degenerate(0.056), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(10, 20), "m/s") # made up - not important here
  ),
  dive = State(
    id = "diving",
    energy_cost = VarDist(dist_normal(3.71, 1.3), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(3.11), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # made up - not important here
  ),
  active = State(
    id = "active_on_water",
    energy_cost = VarDist(dist_normal(113, 22), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(10.5), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # made up - not important here
  ),
  inactive = State(
    id = "inactive_on_water",
    energy_cost = VarDist(dist_normal(72.2, 22), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(10.3), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # made up - not important here
  ),
  colony = State(
    id = "colony",
    energy_cost = VarDist(dist_normal(33.8, 11.4), units = "kJ/hour"), # from spreadsheet
    time_budget = VarDist(dist_degenerate(0), "hours/day"), # no time at colony
    speed = VarDist(0, "m/s") # made up - not important here
  )
)
```

Other high-level configurations.


```{r}


# IBM settings -------------------------------------------------

isle_may <- st_sf(
  id = "Isle of May",
  prop = 1,
  geom = st_sfc(st_point(c(-2.5667, 56.1833))),
  crs = 4326
)


# Specify <Species>  -------------------------------------------------

guill <- Species(
  id = "guill",
  common_name = "guillemot",
  scientific_name = "Uria Aalge",
  pop_size = 15000,
  body_mass_distr = VarDist(dist_uniform(600, 1450), "g"),
  mortality_thresh_distr = VarDist(800, "g"),
  states_profile = states,
  driver_responses = driver_resp
)


# IBM Settings - modify parameter values to your specific case
guill_imb_config <- ModelConfig(
  n_agents = 1,
  ref_sys = utm30,
  aoc_bbx = AoC, #
  delta_x = 1000,
  delta_y = 1000,
  time_step = "1 day",
  start_date = date("2025-07-01"),
  end_date = date("2025-07-01") + 240, # ~9 months
  start_sites = isle_may |> st_transform(utm30),
  end_sites = isle_may |> st_transform(utm30)
)
```

The most time-consuming element of this is likely determining the "distance-to" things that influence the agents. The obvious one relevant here are the OWF - excluded currently for dev. Need for counter-factual runs.

```{r}
# Initiate Agent  -------------------------------------------------

guill_ibm <- rmr_initiate(
  species = guill,
  drivers = guill_drivers,
  model_config = guill_imb_config
)
```

## Constructing agents and running the simulation

The initiation of the IBM creates agents (`n_agents = 1`) however, for our purposes these are being made individually below. Here create 4 in a list (`agent_list`). There is a slight alteration of the history element here to respect the reference system of the IBM (will be future fix).

```{r}
agent_list <- list()
  n_agents <- 8

  set.seed(4958)

  for(i in 1:n_agents){

  agent_list[[i]] <- Agent(species = guill, model_config = guill_imb_config)

  agent_list[[i]]@history <- agent_list[[i]]@history |>
    st_set_crs(guill_imb_config@ref_sys)

  } 
```

The simulation is run for each agent in the list. The `sequent_runs` object is a list of the results for each agent. We'll only run for the first one, for timing and looking at structure. Parallelised using `furrr`.


```{r}

future::plan(future::multisession, workers = 4)

system.time({

sequent_runs <- furrr::future_map(agent_list, \(x) bioss_run_sim(in_agent = x, in_ibm = guill_ibm, in_species = guill, in_ibm_config = guill_imb_config,
            in_density = guill_ibm@drivers$dens@stars_obj), .progress = T, .options = furrr::furrr_options(seed = T))
  
})

```


## Querying the outputs


Each of the agents has 3 slots:

* `condition`: this contains the current state of the agent as it progresses through the simulation e.g. position, weight etc. At the end of the simulation it will contain its final state. Elements of this are progressively used to populate the history slot below.
* `properties`: the over-arching properties governing the agent which are fixed throughout the simulation. Elements of this are derived from the species properties and populated at the initialisation of the agent.
* `history`: elements of the agent's condition recorded over time. 



```{r}

slotNames(sequent_runs[[1]])

```

For example, the bodymass of the agent is recorded over time. The stochasticity here is defined at the species-level and as implemented for this example, the agent-level energetics parameters vary over time.


```{r}
hist_obj <- sequent_runs[[1]]@history

ggplot(hist_obj) + 
  geom_point(aes(x = 1:nrow(hist_obj), y = units::drop_units(body_mass)), fill = "blue", col = "blue", alpha = 0.5) +
  xlab("day") +
  ylab("bodymass (g)") +
  theme_light()
```
## Counter-factual runs

It is assumed here that there are only a binary comparison of unimpacted and impacted runs. Each agent will create a pair whose starting conditions are identical. This means common random seeds for stochastic components, although they are expected/allowed to deviate over time given the variable pressures applied through impact scenarios.

Here we run a counter-factual set for the previous example agents. Note, only a proportion of agents are deemed responsive to the impacts, but they will all still be subject to the density dependent energy implications of those agents that are responsive. 

```{r}

# some code

```

### Counter-factual comparisons

Here we summarise the impacts in terms of effects on energetics. Note, by design the agents will attempt to mitigate reductions in feeding success/energy inputs by modifying their activity budgets.

```{r}

# some code

```







