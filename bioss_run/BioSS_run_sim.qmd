---
title: "bioss_run_sim"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
---

## Initialise the IBM

The following is largely the same as previous, but now uses your SST data.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| output: false

library(tidyverse)
library(roamR)
library(stars)
library(sf)
library(distributional)

# UTM zone 30N
utm30 <- st_crs(32630)


# Input data layers -----------------------------------------------------------------------------------------------
# datacubes: density, lat/lon/, month
spec_map <- readRDS("data/guill_dens.rds") %>% 
  rename(density = X10) 

conspec_map <- readRDS("data/guill_conspec.rds") %>%
  rename(density = layer.1)

spec_imp_map <- readRDS("data/guill_dens_clipped.rds") 
spec_imp_map_p <- spec_imp_map$p
spec_imp_map <- spec_imp_map$d %>%
  rename(density = X10)

conspec_imp_map <- readRDS("data/guill_conspec_clipped.rds") 
conspec_imp_map_p <- conspec_imp_map$p
conspec_imp_map <- conspec_imp_map$d %>%
  rename(density = layer.1)

# clip and revise odd projection
dens_crop <- st_bbox(c(xmin = 178831, ymin = 5906535,  xmax = 1174762, ymax = 6783609), crs = st_crs(utm30))

template_rast <- st_as_stars(spec_map |> st_transform(utm30) |> st_bbox(),
                             nx = dim(spec_map)[1], ny = dim(spec_map)[2], values = NA_real_)

spec_map <- spec_map %>% st_warp(dest = template_rast) %>% st_crop(dens_crop) 
conspec_map <- conspec_map %>% st_warp(dest = template_rast) %>% st_crop(dens_crop) 
spec_imp_map <- spec_imp_map %>% st_warp(dest = template_rast) %>% st_crop(dens_crop) 
conspec_imp_map <- conspec_imp_map %>% st_warp(dest = template_rast) %>% st_crop(dens_crop) 

# note, month number is used, so no more than one year's data

sst <- readRDS("data/bioss_sst_stars.rds")


# IBM settings -------------------------------------------------

isle_may <- st_sf(
  id = "Isle of May",
  prop = 1,
  geom = st_sfc(st_point(c(-2.5667, 56.1833))),
  crs = 4326
)



# Set up IBM drivers ----------------------------------------------------------------------------------------------

sst_drv <- Driver(
  id = "sst",
  type = "habitat",
  descr = "Sea Surface Temperature",
  stars_obj = sst
)


dens_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "species dens map",
  stars_obj = spec_map
)

dens_imp_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "species redist map",
  stars_obj = spec_imp_map
)

consp_drv <- Driver(
  id = "consp_dens",
  type = "impact",
  descr = "conspecific dens map",
  stars_obj = conspec_map
)

consp_imp_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "consp redist map",
  stars_obj = conspec_imp_map
)

# store as list for initialisation
guill_drivers <- list(
  sst = sst_drv,
  dens = dens_drv,
  consp = consp_drv,
  dens_imp = dens_imp_drv,
  consp_imp = consp_imp_drv
)


# Response to drivers  -------------------------------------------------

driver_resp <- list()
```

Of more direct interest here, are the uncertainties around the energetics calculations.Currently these are used to generate stochastic value for each of the agents.


```{r}
# States specification -------------------------------------------------

states <- list(
  flight = State(
    id = "flight",
    energy_cost = VarDist(dist_normal(507.6, 237.6), units = "kJ/hour"), # vals from excel sheet. Normal may not be adequate (some good chance of <zero) - there is a catch for this
    time_budget = VarDist(dist_degenerate(0.056), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(10, 20), "m/s") # made up - not important here
  ),
  dive = State(
    id = "diving",
    energy_cost = VarDist(dist_normal(3.71, 1.3), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(3.11), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # made up - not important here
  ),
  active = State(
    id = "active_on_water",
    energy_cost = VarDist(dist_normal(113, 22), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(10.5), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # made up - not important here
  ),
  inactive = State(
    id = "inactive_on_water",
    energy_cost = VarDist(dist_normal(72.2, 22), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(10.3), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # made up - not important here
  ),
  colony = State(
    id = "colony",
    energy_cost = VarDist(dist_normal(33.8, 11.4), units = "kJ/hour"), # from spreadsheet
    time_budget = VarDist(dist_degenerate(0), "hours/day"), # no time at colony
    speed = VarDist(0, "m/s") # made up - not important here
  )
)

# Specify <Species>  -------------------------------------------------

guill <- Species(
  id = "guill",
  common_name = "guillemot",
  scientific_name = "Uria Aalge",
  pop_size = 15000,
  body_mass_distr = VarDist(dist_uniform(600, 1450), "g"),
  mortality_thresh_distr = VarDist(800, "g"),
  states_profile = states,
  driver_responses = driver_resp
)


# IBM Settings - modify parameter values to your specific case
guill_imb_config <- ModelConfig(
  n_agents = 1,
  ref_sys = utm30,
  aoc_bbx = dens_crop |> st_transform(utm30) |>  st_bbox(), #
  delta_x = 1000,
  delta_y = 1000,
  time_step = "1 day",
  start_date = date("2025-07-01"),
  end_date = date("2025-07-01") + 240, # ~9 months
  start_sites = isle_may |> st_transform(utm30),
  end_sites = isle_may |> st_transform(utm30)
)
```


```{r}
# Initiate Agent  -------------------------------------------------

guill_ibm <- rmr_initiate(
  species = guill,
  drivers = guill_drivers,
  model_config = guill_imb_config
)
```

## Constructing agents and running the simulation

The initiation of the IBM creates agents (`n_agents = 1`) however, for our purposes these are being made individually below. Here create 4 in a list (`agent_list`). There is a slight alteration of the history element here to respect the reference system of the IBM (will be future fix).

```{r}
agent_list <- list()
  n_agents <- 4

  set.seed(4958)

  for(i in 1:n_agents){

  agent_list[[i]] <- Agent(species = guill, model_config = guill_imb_config)

  agent_list[[i]]@history <- agent_list[[i]]@history %>%
    st_set_crs(guill_imb_config@ref_sys)

  } # eol i
```

The simulation is run for each agent in the list. The `sequent_runs` object is a list of the results for each agent. We'll only run for the first one, for timing and looking at structure.


```{r}


system.time({
  

sequent_runs <- lapply(agent_list[1], \(x) bioss_run_sim(in_agent = x, in_ibm = guill_ibm, in_species = guill, in_ibm_config = guill_imb_config,
            in_density = guill_ibm@drivers$dens@stars_obj))

})

```


```{r}

slotNames(sequent_runs[[1]])

```

```{r}
hist_obj <- sequent_runs[[1]]@history

plot(hist_obj$body_mass, xlab = "timestep", ylab = "bodymass", col = "blue") 
```


