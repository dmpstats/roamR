---
title: "bioss_run_sim"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
---

## Setting up the IBM runs

Parallelisation, counter-factuals

## Initialise the IBM

Input data, species & model configurations etc

### Spatio-temporal inputs

Species, conspecifics and SST. Pre-prepared (clipped to AoC and projected to UTM30).

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| output: false

library(tidyverse)
library(roamR)
library(stars)
library(sf)
library(distributional)

# UTM zone 30N
utm30 <- st_crs(32630)


# AoC in UTM. Exact figures come from a previous lat/lon example
AoC <- st_bbox(c(xmin = 178831, ymin = 5906535,  xmax = 1174762, ymax = 6783609), crs = st_crs(utm30))


# location of colony - start/finish locations

isle_may <- st_sf(
  id = "Isle of May",
  prop = 1,
  geom = st_sfc(st_point(c(-2.5667, 56.1833))),
  crs = 4326
)



# IBM Settings - assume fixed for these simulations

guill_imb_config <- ModelConfig(
  n_agents = 1,
  ref_sys = utm30,
  aoc_bbx = AoC, #
  delta_x = 1000,
  delta_y = 1000,
  time_step = "1 day",
  start_date = date("2025-07-01"),
  end_date = date("2025-07-01") + 270, # ~9 months
  start_sites = isle_may |> st_transform(utm30),
  end_sites = isle_may |> st_transform(utm30)
)


# Input data layers -----------------------------------------------------------------------------------------------
# datacubes: density, lat/lon/, month
spec_map <- readRDS("data/bioss_spec_map.rds")

conspec_map <- readRDS("data/bioss_conspec_map.rds") 

spec_imp_map <- readRDS("data/bioss_spec_imp_map.rds") 

conspec_imp_map <- readRDS("data/bioss_conspec_imp_map.rds") 

energy_imp_map <- readRDS("data/bioss_energy_imp_map.rds")

sst <- readRDS("data/bioss_sst_stars.rds")






```

Put these in as `roamR` drivers. Exclude conspecifics for dev.

```{r}
# Set up IBM drivers ----------------------------------------------------------------------------------------------

sst_drv <- Driver(
  id = "sst",
  type = "habitat",
  descr = "Sea Surface Temperature",
  stars_obj = sst
)


dens_drv <- Driver(
  id = "dens",
  type = "impact",
  descr = "species dens map",
  stars_obj = spec_map
)

dens_imp_drv <- Driver(
  id = "dens_imp",
  type = "impact",
  descr = "species redist map",
  stars_obj = spec_imp_map
)

consp_drv <- Driver(
  id = "consp_dens",
  type = "impact",
  descr = "conspecific dens map",
  stars_obj = conspec_map
)

consp_imp_drv <- Driver(
  id = "consp_imp_dens",
  type = "impact",
  descr = "conspecific redist map",
  stars_obj = conspec_imp_map
)


energy_imp_drv <- Driver(
  id = "energy_imp",
  type = "impact",
  descr = "energy impact map",
  stars_obj = energy_imp_map
)


# store as list for initialisation
guill_drivers <- list(
  sst = sst_drv,
  dens = dens_drv,
  consp = consp_drv,
  dens_imp = dens_imp_drv,
  consp_imp = consp_imp_drv,
  energy_imp = energy_imp_drv
)
```

### Species and model configurations

These are the elements to be adjusted for the simulations in hand (as initially assuming datacubes are fixed):

-   Means/variances of energy cost functions (inside `states` definition list)
-   Mean/variance of bodymass distribution (defined in the `Species` class object)
-   The parameter `p_imp_response` which governs the probability an agent is responsive to an OWF development

**States**:

```{r}
# States specification -------------------------------------------------

states <- list(
  flight = State(
    id = "flight",
    energy_cost = VarDist(dist_normal(507.6, 237.6), units = "kJ/hour"), # vals from excel sheet. Normal may not be adequate (some good chance of <zero) - there is a catch for this
    time_budget = VarDist(dist_degenerate(0.056), "hours/day"), # Based on Lila's summary data
    speed = VarDist(dist_uniform(10, 20), "m/s") # placeholder, not very relevant
  ),
  dive = State(
    id = "diving",
    energy_cost = VarDist(dist_normal(3.71, 1.3), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(3.11), "hours/day"), # roughly based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # placeholder, not very relevant
  ),
  active = State(
    id = "active_on_water",
    energy_cost = VarDist(dist_normal(113, 22), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(10.5), "hours/day"), # Based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # placeholder, not very relevant
  ),
  inactive = State(
    id = "inactive_on_water",
    energy_cost = VarDist(dist_normal(72.2, 22), units = NULL), # from spreadsheet
    time_budget = VarDist(dist_degenerate(10.3), "hours/day"), # Based on Lila's summaries
    speed = VarDist(dist_uniform(0, 1), "m/s") # placeholder, not very relevant
  ),
  colony = State(
    id = "colony",
    energy_cost = VarDist(dist_normal(33.8, 11.4), units = "kJ/hour"), # from spreadsheet
    time_budget = VarDist(dist_degenerate(0), "hours/day"), # no time at colony
    speed = VarDist(0, "m/s") # placeholder, not very relevant
  )
)
```

**Species definition (bodymass of interest)**

```{r}

# Specify <Species>  -------------------------------------------------

guill <- Species(
  id = "guill",
  common_name = "guillemot",
  scientific_name = "Uria Aalge",
  pop_size = 15000,
  body_mass_distr = VarDist(dist_normal(mean = 929, sd = 56), "g"), # mean from kate CEH doc - sd digitising Francis' plot
  mortality_thresh_distr = VarDist(800, "g"), # not used specifically - dealt with in post-processing (e.g. <60% of starting bodymass)
  states_profile = states,
  driver_responses = list()
)


# probability an agent responds to OWF - a Bioss sensitivity parameter
# Spreadsheet sets this to 67%, with (95% ?) CI of 53-77. NB implies a SD of abount 6.1 if normal approx
# use mean for example run

p_imp_response <- 0.67


```

A series of internal calculations required to initialise the IBM.

```{r}
# Initiate Agent  -------------------------------------------------

guill_ibm <- rmr_initiate(
  species = guill,
  drivers = guill_drivers,
  model_config = guill_imb_config
)
```

## Constructing agents and running the simulation

The initiation of the IBM can create an arbitrary number of agents (via `n_agents = X`) however, for our purposes these are being made individually below. Here we create 8 in a list (`agent_list`). There is a slight alteration of the history element here to respect the reference system of the IBM (will be future fix).

```{r}
agent_list <- list()
  n_agents <- 8

  set.seed(4958)

  for(i in 1:n_agents){

  agent_list[[i]] <- Agent(species = guill, model_config = guill_imb_config)

  agent_list[[i]]@history <- agent_list[[i]]@history |>
    st_set_crs(guill_imb_config@ref_sys)
  
  agent_list[[i]]@properties@move_influences <- list(owf_imp = rbinom(1, 1, p_imp_response))

  } 
```

The simulation is run for each agent in the list. The `sequent_runs` object is a list of the results for each agent. We'll only run for the first one, for timing and looking at structure. Parallelised using `furrr`.

```{r}

future::plan(future::multisession, workers = 4)

set.seed(34958) # important this be set to allow paired runs with the impacted scenarios

system.time({
  
sequent_runs <- furrr::future_map(agent_list, \(x) bioss_run_sim(
            in_agent = x, in_ibm = guill_ibm,
            in_species = guill, 
            in_ibm_config = guill_imb_config,
            mean_intake = 543,
            impact = F), # OWF information is ignored
            .progress = T, .options = furrr::furrr_options(seed = T))

})

```

## Querying the outputs

Each of the agents has 3 slots:

-   `condition`: this contains the current state of the agent as it progresses through the simulation e.g. position, weight etc. At the end of the simulation it will contain its final state. Elements of this are progressively used to populate the history slot below.
-   `properties`: the over-arching properties governing the agent which are fixed throughout the simulation. Elements of this are derived from the species properties and populated at the initialisation of the agent.
-   `history`: elements of the agent's condition recorded over time.

```{r}

slotNames(sequent_runs[[1]])

```

For example, the bodymass of the agent is recorded over time. The stochasticity here is defined at the species-level and as implemented for this example, the agent-level energetics parameters vary over time.

```{r}
hist_obj <- lapply(sequent_runs, \(x) x@history)

names(hist_obj) <- paste0("agent_", 1:length(hist_obj))

hist_obj <- bind_rows(hist_obj, .id = "agent_id") |> 
  mutate(impact = F)

ggplot(hist_obj) + 
  geom_point(aes(x = timestep, y = units::drop_units(energy_expenditure)), fill = "blue", col = "blue", alpha = 0.5) +
  xlab("day") +
  ylab("cumulative energy (kJ)") +
  theme_light() +
  facet_wrap(~agent_id, ncol = 2)
```

```{r}
ggplot(hist_obj, aes(x = timestep, y = units::drop_units(body_mass))) + 
  geom_point(fill = "grey", col = "black", alpha = 0.5) +
  xlab("day") +
  ylab("Implied body-mass (g)") +
  geom_smooth() +
  theme_light() +
  facet_wrap(~agent_id, ncol = 2)

```

## Counter-factual runs

It is assumed here that there are only a binary comparison of unimpacted and impacted runs. Each agent will create a pair whose starting conditions are identical. This means common random seeds for stochastic components, although they are expected/allowed to deviate over time given the variable pressures applied through impact scenarios.

Here we run a counter-factual set for the previous example agents. Note, only a proportion of agents are deemed responsive to the impacts, but they will all still be subject to the density dependent energy implications of those agents that are responsive.

```{r}

future::plan(future::multisession, workers = 4)

set.seed(34958) # seed matches previous run for pairing

system.time({

sequent_imp_runs <- furrr::future_map(agent_list, \(x) bioss_run_sim(
            in_agent = x, in_ibm = guill_ibm,
            in_species = guill, 
            in_ibm_config = guill_imb_config,
            mean_intake = 543,
            impact = T), # OWF information is observed
            .progress = T, .options = furrr::furrr_options(seed = T))
  
})

```

### Counter-factual comparisons

Here we summarise the impacts in terms of effects on energetics. Note, by design the agents will attempt to mitigate reductions in feeding success/energy inputs by modifying their activity budgets. The comparisons here are based solely on:

-   Comparison of energy expenditure over the simulation/NBS for the impacted/non-impacted.
-   The proportion of time spent in each activity state (flight, dive, active, inactive) over the simulation/NBS, for the impacted/non-impacted.

Combine the simulations into one DF:

```{r}

imp_hist_obj <- lapply(sequent_imp_runs, \(x) x@history)

names(imp_hist_obj) <- paste0("agent_", 1:length(imp_hist_obj))

imp_hist_obj <- bind_rows(imp_hist_obj, .id = "agent_id") |> 
  mutate(impact = T)


comp_df <- bind_rows(hist_obj, imp_hist_obj) 
  

```

Consider first the cumulative energy expenditure. Note these seem unreasonably variable, but are a natural consequence of the energetics equations and their parameter distributions as currently provided.

```{r}

library(units)

energy_summ <- comp_df |> 
  group_by(agent_id, impact) |>
  summarise(
    mean_energy = mean(energy_expenditure)
  ) |> 
  mutate(mean_energy = units::drop_units(mean_energy))
  
```

Comparatively for the 8 agents run:

```{r}


ggplot(energy_summ) +
  geom_point(aes(agent_id, mean_energy, col = impact), size = 3) +
  ggthemes::scale_color_fivethirtyeight() +
  ggtitle("NBS cumulative energy expenditure", "Impacted vs unimpacted") +
  ylab("Mean energy expenditure (kJ)") +
  theme_light()
  


```

Looking crudely at the distribution of activity states for the NBS. Just taking means of proportions for each agent over the NBS, and comparing for their impacted/non-impacted states:

```{r}

activity_summ <- comp_df |> 
  group_by(agent_id, impact) |>
  summarise(
    mean_dive = mean(states_budget.dive),
    mean_flight = mean(states_budget.flight),
    mean_active = mean(states_budget.active),
    mean_inactive = mean(states_budget.inactive)
  ) |> 
  as.data.frame() |> 
  select(-geometry) |> 
  pivot_longer(names_to = "activity", values_to = "proportion", -c(agent_id, impact)) |> 
  group_by(agent_id, activity) |> 
  mutate(diff = 24*60*(proportion[2] - proportion[1])) |> 
  select(-impact) |> 
  distinct()


ggplot(activity_summ) +
  rcartocolor::scale_fill_carto_d(palette = "Geyser") +
  geom_bar(aes(x = agent_id, y = diff, fill = activity), stat = "identity") +
  ylab("Mean difference impact - unimpacted (mins per day)") +
  ggtitle("Difference in time spent in activities", "Impacted vs unimpacted") 
 
```
