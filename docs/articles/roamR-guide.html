<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>`roamR` - package overview • roamR</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="`roamR` - package overview">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">roamR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item"><a class="nav-link" href="../articles/index.html">Articles</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>`roamR` - package overview</h1>
            
      

      <div class="d-none name"><code>roamR-guide.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p><code>roamR</code> is an R package that offers a toolset and
framework for running Individual Based Models (IBMs - or Agent-Based
Models). It was created as part of the DisNBS project (Distribution of
seabirds in the Non-Breeding Season) which was a project within the
Offshore Renewables Joint Industry Partnership programme (<a href="http://www.orjip.org.uk/" class="external-link">ORJIP</a>). While the project has
specific goals in relation to Offshore Wind Farms (OWF) and their
potential effects on seabirds, the problem is quite general. This
package helps build animal movement simulations, with the general
problem broken down into logical components, and imposes a level of
transparent formality. This places the computational components on a
common footing, leaving focus on the parametrisation and
inputs/data.</p>
<p>IBMs are simple in principle - they simulate the movement of
individual animals in response to their environment and measure
properties from them e.g. their body-mass. They are particularly useful
where analytical modelling is difficult and where “what-if” scenarios
are sought, meaning the system can be examined with/without a
speculative perturbation. They also accommodate
stochasticity/uncertainty quite naturally. Typically many simulated
agents are run such that uncertainty in the inputs are reflected in any
measured outputs, so conclusions are tempered accordingly.</p>
<p>The DisNBS project is the motivating example for the package
development, which seeks to simulate seabirds in the non-breeding season
(the extant IBM tool SeaBORD covers the breeding season), to explore and
quantify the effects of speculative OWF development scenarios. The
ultimate output is a generic IBM (in terms of UK seabirds) predicting
the demographic effects of displacement for seabird species in the
non-breeding season</p>
<div class="section level3">
<h3 id="ibm-design-disnbs-workpackage-1">IBM design (DisNBS workpackage 1)<a class="anchor" aria-label="anchor" href="#ibm-design-disnbs-workpackage-1"></a>
</h3>
<p>The DisNBS started with a design phase, underpinned by an expert
consultation workshop. The resulting generic structure is presented in
figure 1, which the <code>roamR</code> package implements. The
demography submodel is not formally part of the IBM, but the energetics
and body mass distributions that are generated will inform these
down-stream calculations.The following document is a high-level
description fo the functionality within the <code>roamR</code> package,
that encompasses the design elements of figure 1. `</p>
<div class="float">
<img src="images%2FWP1_schema_nocap.svg" alt="Figure 1 - Schematic of proposed structure of IBM. Types of components: biological/ecological (gold), environmental (purple), OWF related (red) and influence the properties of the agents (blue) leading to final outputs (green)"><div class="figcaption">Figure 1 - Schematic of proposed structure of
IBM. Types of components: biological/ecological (gold), environmental
(purple), OWF related (red) and influence the properties of the agents
(blue) leading to final outputs (green)</div>
</div>
</div>
<div class="section level3">
<h3 id="package-overview">Package overview<a class="anchor" aria-label="anchor" href="#package-overview"></a>
</h3>
<p><code>roamR</code> is written in R using S4 classes (refer <a href="https://adv-r.hadley.nz/s4.html" class="external-link">here</a> for an overview and
later section) and has been structured/implemented such that the
simulations are well defined, but with a lot of flexibility in what the
components can do. S4 programming imposes a level of formality to the
programming that helps make the software more robust. Animal IBMs are
spatiotemporal and can be based on very disparate data sources - so
<code>roamR</code> is particular in its treatment of space (projections
etc), time and units generally (as found in the <code>units</code>
package). The package was written with seabirds as the motivating case,
but generally for animals (indeed one of the main classes is
<code>Species</code>), noting the agnostic term <strong>agent</strong>
applies.</p>
<p>In brief - <code>roamR</code>:</p>
<ul>
<li><p>defines the general characteristics of a type of agent (a
<em>species</em> definition)</p></li>
<li><p>defines the environment the agent interacts with, and how this
functionally affects its movement or behaviour</p></li>
<li><p>defines how agents move, with consideration of the environment,
behavoural state, or body condition</p></li>
<li><p>defines the behaviours animals may engage in and how these
change</p></li>
<li><p>creates many agents with stochastic properties in line with their
species definition</p></li>
<li><p>runs the agents through the simulated environment over time, for
a defined temporal resolution</p></li>
<li><p>measures the agents throughout the simulation</p></li>
<li><p>gives tools to query the condition of agents that have been
simulated</p></li>
</ul>
<p>A principal limitation in IBMs is the level of information you have
available to parameterize how the agents behave. <code>roamR</code> is
intended to function well across the data support spectrum (i.e. from
information poor to information rich). The test cases here cover a range
of data support:</p>
<ul>
<li><p>Relatively data rich: Guillemots at the Isle of May, which are
well studied.</p></li>
<li><p>Relatively data poor: Red-Throated Divers in the North Sea, which
are less understood.</p></li>
</ul>
<p>At the more extreme information end, <code>roamR</code> has been
developed to simulate agents at a very detailed level, for example a
population with extensive GPS tagging information. The exemplar that
guided this was the Hidden Markov Model of McClintock &amp; Michelot
(2018) and subsequent fitting to detailed Fulmar track data.</p>
</div>
<div class="section level3">
<h3 id="r-and-s4-programming">R and S4 programming<a class="anchor" aria-label="anchor" href="#r-and-s4-programming"></a>
</h3>
<p>This package assumes at least some minor familiarity with R. Its use
for simulating birds in the context of OWF is illustrated using markdown
in the associated example scenarios - avoiding the need for detailed R
programming knowledge. These examples give the steps required which can
be modified and followed for new cases. However, even within this
use-case it is unavoidable that user-defined functions will be required:
for example the energetics equations for a particular species’ activity
states. There are a lot of features of the package that extend it well
beyond these OWF seabird examples, but will require a deeper
understanding of R in order to fully use these. In particular some
familiarity with S4 is useful if you want to use the package beyond the
narrow path for the bird IBMs that motivated the package. Regardless,
there is some basic S4 information that is useful to bear in mind:</p>
<ul>
<li><p>There are well-defined classes for many components of the
simulation - the R objects will often contain <em>slots</em> that you
access by name with the <code>@</code> operator, as opposed to the
<code>$</code> that is common for simple R objects.</p></li>
<li><p>Classes are prescriptive in what they can contain, this means
things are more robust but deviations will be rejected e.g. if the data
is <strong>required</strong> to be a <code>stars</code> object, you
cannot store something else there</p></li>
<li><p>There are a lot of background checks for conformity (as above),
so what you do will be scrutinised at various levels and prevented if
outside expectations. For example, spatial elements must carry
coordinate references systems and projections, units must be specified
for many inputs.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="dependencies">Dependencies<a class="anchor" aria-label="anchor" href="#dependencies"></a>
</h3>
<p>The package has been written with the intention of few dependencies
on other packages. The dependencies that are needed have been chosen
with stability and longevity in mind i.e. they are well maintained and
programmed, where differing options are available. Notable examples
are:</p>
<ul>
<li><p>The <code>sf</code> (simple features) package, which is widely
well regarded for spatial work and encompasses much functionality of
other packages.</p></li>
<li><p>The <code>stars</code> packages for dealing with spatiotemporal
data structures, which is characteristic of much of the data required
for animal movement IBMs.</p></li>
</ul>
<p><strong>Note:</strong> the <code>units</code> package is used
heavily. Many parameters and data elements <em>must</em> have their
units of measurement specified. This is one of several formalities the
package imposes, to minimise careless errors and make the simulations
well defined. The help files state where these requirements apply.</p>
</div>
</div>
<div class="section level2">
<h2 id="packageclass-hierarchy">Package/class hierarchy<a class="anchor" aria-label="anchor" href="#packageclass-hierarchy"></a>
</h2>
<p>A great deal of thought has gone into the hierarchical structure,
which means mainly the classes, how they relate to one another and
therefore where data (including parameters) lies within these. This is
summarised in the figure below:</p>
<p><img src="images%2FroamR_schema.png" class="zoomable" alt="general class structure and hierarchy for the `roamR` package"></p>
<p>Key elements of this are discussed in turn, and examples are given in
the associated test scenarios. Four main areas are covered:</p>
<ul>
<li><p>The simulation engine and wrapper - offering high-level controls,
like the number of agents, spatial/temporal boundaries (e.g. a bounding
box, as distinct to environmental constraints of the simulation,
fundamental spatial coordinate system</p></li>
<li><p>The species - properties of the population being simulated
e.g. distributions of initial body mass, flying speeds. These are often
distributional, as agents/individuals will be generate from
these.</p></li>
<li><p>The environment - spatiotemporal descriptions of the agent’s
environment within the simulation frame e.g. natural boundaries (coast),
the Sea Surface Temperature (SST) over time, man-made structures
(e.g. OWF)</p></li>
<li><p>The agents - the basic simulation element, largely defined from
higher components, but the basis of monitoring the simulation and any
counterfactuals</p></li>
</ul>
<div class="section level3">
<h3 id="general-workflow-to-createrun-an-ibm">General workflow to create/run an IBM<a class="anchor" aria-label="anchor" href="#general-workflow-to-createrun-an-ibm"></a>
</h3>
<p>The workflow to create/populate a <code>roamR</code> IBM is in
essence:</p>
<ol style="list-style-type: decimal">
<li><p>Configure the simulation at a high-level, including the spatial
and temporal boundaries, projections, number of agents etc.</p></li>
<li><p>Define the species, for example initial body mass distributions,
flight speed distributions, activity states and their energetic
implications, functional relationships between the species and the
environment e.g. how SST affects energy, how OWFs influence
movement/distribution.</p></li>
<li><p>Define the environment, essentially anything spatio-temporal that
the animals are thought to respond to - coastline, man-made structures
(e.g. OWF), prey distributions, SST, bathymetry etc.</p></li>
<li><p>Combine components into an IBM object.</p></li>
<li><p>Run a simulation, which creates agents, parallelises
calculations, moves agents through the environment, and records their
properties over time.</p></li>
<li><p>Alter simulation elements to reflect a perturbation (presence of
OWF).</p></li>
<li><p>Re-run the simulation with the perturbation.</p></li>
<li><p>Query simulated animals, with counterfactuals based on
within-agent comparisons over perturbation scenarios.</p></li>
</ol>
<p>The key classes that require population in this workflow are expanded
upon in turn.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-high-level-control-modelconfig-class">The high level control (<code>ModelConfig</code>, class)<a class="anchor" aria-label="anchor" href="#the-high-level-control-modelconfig-class"></a>
</h2>
<p>This component provides the high-level configurations for the
simulation, such as the spatial and temporal boundaries, the
spatiotemporal resolution, the number of agents to simulate, the
projection of the spatial data, and other general parameters that define
the simulation environment. This also includes start and finish points
for simulated animals, if that some return-to-colony behaviour is
required. Consideration in the setting of these follows.</p>
<p><strong>Bounding Box</strong> (<code>aoc_bbx</code>) this is a
spatial extent over which the agents are constrained to be within. In
many cases this will simply dictated by the data, for example a density
distribution for the animal being simulated. If the animals have very
low probability of being beyond this data, then the bounding box
constraint is a logical progression. In other cases it might be set with
knowledge of the maximum range of the animal’s home range.</p>
<p>It is important to note that no movement outside this is permitted -
so the box should be sufficiently large that it is not controversially
influential i.e. err on the large side given other inputs will dictate
travel. It also will bound spatiotemporal inputs, so data inputs are
clipped to this region. A potential consequence of making the bounds
very large is that large amounts of data be retained needlessly.</p>
<p><strong>Spatial Resolution</strong> (<code>delta_x</code>,
<code>delta_y</code>) this defines the resolution of any spatiotemporal
datacubes that underpin the IBM. Note, this does not define the
resolution of the movements of the agent, just the resolution of data
describing its environment. This can simply be set to match the finest
scale of the input data, the only cost being the size of data being
carried forwards.</p>
<p><strong>Temporal Bounds</strong> (<code>start_date</code>,
<code>end_date</code>) a nominal period the simulation applies to. Some
care is needed such that input data covers this period. For example, if
the simulation is envisaged to be running in the future, temporal inputs
should similarly be nominally for this period e.g. if using historic SST
data, this needs to be timestamped for the projected simulation
period.</p>
<p><strong>Number of agents</strong> (<code>n_agents</code>) there is no
strong guidance on this, but is should be a considered choice. A general
rule of thumb is that more would be better (similar to any computer
intensive inference) so should be “large”. Note, the amount of
calculation, and hence time to run the simulation, is linear with
regards this. Similarly agents are tracked and stored in detail, so may
result in non-negligible storage sizes.</p>
<p>Ultimately the the outputs will be distributions of metrics from the
agents, so sufficient are needed to characterise these distributions
well/stably. A balance of computation time and accuracy of the
distribution shape may be needed, if computation time is large - else
just select a large number. The number of agents does <em>not</em> need
to match the number of individuals in the population being simulated,
they represent a sample of potential realities or animals as for any
computer-intensive inference.</p>
</div>
<div class="section level2">
<h2 id="defining-the-species-species-class">Defining the species (<code>Species</code> class)<a class="anchor" aria-label="anchor" href="#defining-the-species-species-class"></a>
</h2>
<p>This provides the general features that are realised in the agents,
either stochastically (e.g. initial body mass) and/or functional
relationships with the environment (e.g. how SST affects energy
expenditure). It has been named <em>species</em> but could be considered
a population depending on the context e.g. if there are parameters known
down to a colony level, and potentially different from other
colonies.</p>
<p><em>[Note the package also has a <code>varDist</code> class, which
gives a common interface in setting stochasticity, based on the
<code>distributional</code> package]</em></p>
<p><strong>Labels</strong> (<code>id</code>, <code>common_name</code>,
<code>scientific_name</code>) these are used to identify the species in
the simulation, and can be used to query the simulation results. They
are not used in any functional way, but are useful for labelling outputs
and queries.</p>
<p><strong>Body mass</strong> (<code>body_mass_distr</code>) this is a
distribution of the initial body mass of the agents, which can be
defined as a <code>VarDist</code> object. This is used to initialise the
agents with a body mass that reflects the population being simulated.
The distribution can be defined using any of the supported distributions
in <code>VarDist</code>, such as normal, log-normal, or gamma
distributions.</p>
<p><strong>Mortality Threshold</strong>
(<code>mortality_thresh_distr</code>) defines thresholds where agents
are considered to have died, based on their body mass. Note, agents are
nominally tracked through the simulation even if marked as dead. This
allows other post-processing relationships to be explored, such as
defining fatality as a function of time spent below a %-age of starting
body mass.</p>
<p><strong>Population Size</strong> (<code>pop_size</code>) this is a
nominal size of the population being simulated, which can be used to
optionally scale the results of the simulation.</p>
<p><strong>Activity States</strong> (<code>activity_states</code>) this
is a list of <code>ActivityState</code> objects, which define the
different states that the agents can be in, such as foraging, resting,
or flying. Each state has a name, a distribution of body mass loss, and
a distribution of flight speed. The states can be defined with different
distributions for different species, and can be used to model the
behaviour of the agents in the simulation.</p>
<p><strong>Response to Environment</strong>
(<code>driver_responses</code>) these are custom defined functions that
relate species (and therefore agent) behaviour with regards their
environment, as represented by the <code>Driver</code> class. These are
a very flexible element of the simulation, so expanded upon below.</p>
<div class="section level3">
<h3 id="driver-responses">Driver responses<a class="anchor" aria-label="anchor" href="#driver-responses"></a>
</h3>
<p>A key element of the IBM is the responsiveness of the agents to their
environment, which includes standard biological factors such as prey
distributions, bathymetry or coastlines. Treated generally, this also
includes anthropogenic factors such as OWF, which are the focus of
perturbation scenarios to be explored in the IBM. These are collectively
termed <strong>drivers</strong>, as they drive agents behaviour,
including movement, activity states and by extension their distribution
and energetics.</p>
<p>The drivers are encompassed in the <code>Driver</code> class below,
which might be themselves general and not species-specific. Here within
the <code>Species</code> class, the link between the environment is made
explicit and species-specific. These are very broad in what they can
encompass, being user-defined. For example:</p>
<ul>
<li><p>Relationships between movement and proximity to coast. The coast
movement driver in this case is distance to coast, calculated internally
from coastline polygons. The correlated random walk movement model is
fundamentally direction and speed, so a sharply declining driver
response influences agents away from coastlines.</p></li>
<li><p>Relationships between movement and OWF. The coast movement driver
in this case is internally calculated distance to development(s), and
the driver function can call on properties of the development
e.g. height of turbines, simulating line-of-sight influences or similar.
Relatedly, this can simply be a barrier effect - the agent cannot pass
through an OWF footprint/polygon (noting a specified proportion of
agents can been set to be sensitive to OWF, also through the species
definition).</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="states-activity-budgets-and-rebalancing">States: activity budgets and rebalancing<a class="anchor" aria-label="anchor" href="#states-activity-budgets-and-rebalancing"></a>
</h3>
<p>The possible activity states of agents are defined within the species
definition as above. A design element of the IBM is that the daily
activity budget (time spent in each state) is not fixed, and can be
responsive to environment and agent condition. <code>roamR</code> allows
a “state rebalancing” on a daily basis, with the rationale that agents
will attempt to compensate for poor foraging say, by increasing the
amount of time dedicated to feeding.</p>
<p><code>roamR</code> allows for this state distribution to be dependent
the previous day’s net energy intake. To achieve this, a target daily
net energy is specified e.g. for a species that is thought to have
similar weights at beginning and end of the season, this target is zero.
A day with poor energy intake will attempt to be compensated for, by a
subsequent increase in time spend feeding. This adjustment is made such
that:</p>
<ul>
<li><p>The change in activity budget would on average balance out the
previous days’ intake against the energy target. Note this will not be
exact, as the daily energy intake achieved is subject to stochastic
elements.</p></li>
<li><p>The changes in activity to seek energy balance are primarily
through increasing/decreasing feeding and resting times.</p></li>
<li><p>Agents are constrained to rest overnight, which is based on day
length calculations for the agent’s location and time.</p></li>
<li><p>All activities outside explicit feeding and resting are scaled
accordingly, such that a full day’s activities are defined (i.e. a
probability distribution for the day is maintained).</p></li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="defining-the-environment-driver-class">Defining the environment (<code>Driver</code> class)<a class="anchor" aria-label="anchor" href="#defining-the-environment-driver-class"></a>
</h2>
<p>Information about the simulated environment which might be
influential on agent’s behaviour is encapsulated in the
<code>Driver</code> class. Generally these are spatiotemporal data cubes
(a data structure here that is effectively a series of maps stacked by
time), such that the agents can query them for any time and location.
The actual information contained within the driver can be of varying
detail (e.g. low spatial resolution, fixed over time, or highly detailed
spatial information that varies with time) but the interface to this is
consistent: the agent queries all relevant drivers at location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="vector-fields">Vector fields<a class="anchor" aria-label="anchor" href="#vector-fields"></a>
</h3>
<p>Generally animals are not simply responsive to their immediate
environment, for example favoured feeding grounds that are not
immediately within their sensory range. <code>roamR</code> includes the
calculation of vector fields, which give direction and slope for any
point on a provided surface. In conjunction with the driver response
functions, this allows the IBM to direct movement through the
environment towards distant favoured regions, or conversely away.
Distance and direction to nearest OWF development, or coastline being
particular examples.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-basic-unit-agent-class">The basic unit (<code>Agent</code> class)<a class="anchor" aria-label="anchor" href="#the-basic-unit-agent-class"></a>
</h2>
<p>The agents within the simulation are treated as self-contained
entities, that are moved and measured through the environment subject to
their individual properties. The specified number of agents are created
at the start of the simulation, with their properties defined by the
<code>Species</code> class. Initialisation of the agents is done by
sampling from the distributions defined in the <code>Species</code>
class, such as initial body mass, flight speed, and activity state.</p>
<div class="section level3">
<h3 id="agent-properties">Agent properties<a class="anchor" aria-label="anchor" href="#agent-properties"></a>
</h3>
<p>At initialisation, the following (non-exhaustive) properties are
generated for each agent. These are fixed throughout the simulation,
being fundamental to the agent for a simulated season:</p>
<p><strong>initial_mass</strong> ⁠<code>units</code>⁠ object, the agent’s
body mass at the start of the simulation.</p>
<p><strong>speeds</strong> a named list, defining movement speed
properties for the agent. Each element specifies the agent’s average
speed for a given movement state (e.g. flying, swimming, etc). List
elements must be of type ⁠<code>units</code>⁠.</p>
<p><strong>start_point</strong>, <strong>end_point</strong> objects of
spatial class <code>XY</code>, the spatial coordinates of the agent at
the start and end of the simulation, respectively.</p>
<p><strong>mortality_thresh</strong> ⁠<code>units</code>⁠ object, the
threshold body mass below which the agent is assumed to die.</p>
<p><strong>move_influences</strong> a named list, defining whether the
agent is influenced by model drivers. Each element corresponds to a
driver_id (which must be defined in the model’s Driver object) and
contains a single-row data.frame with columns:</p>
<ul>
<li><p>p: numeric, providing the probability that the agent is
influenced by the named driver.</p></li>
<li><p>infl: logical, whether the agent is influenced by the driver. It
should be determined via a Bernoulli trial with probability p.</p></li>
</ul>
<p><strong>state_influences</strong> a named list, defining whether
agent states are influenced by model drivers. Each element, named after
a driver_id, contains a data.frame with columns:</p>
<ul>
<li><p>state_id: character string, the unique identifier of an agent’s
state.</p></li>
<li><p>p: numeric, the probability that the agent’s state_id is
influenced by the driver.</p></li>
<li><p>infl: logical, whether the agent’s state_id is influenced by the
driver. It should be determined via a Bernoulli trial with probability
p.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="agent-condition">Agent condition<a class="anchor" aria-label="anchor" href="#agent-condition"></a>
</h3>
<p>The agent’s condition is a dynamic aspect of the simulation, which is
updated at each time-step. It includes the agent’s current location,
body mass, activity states, and other properties that change over time.
The condition is updated based on the agent’s movement, activity states,
and interactions with the environment:</p>
<p><strong>location</strong> object of class XY, specifying the agent’s
spatial coordinates at the end of the current time-step.</p>
<p><strong>grid_cell</strong> object of class XY, representing the AOC’s
grid-cell occupied by the agent.</p>
<p><strong>timestep</strong> integer, indicating the current simulation
time-step index.</p>
<p><strong>timestamp</strong> a ⁠<code>POSIXct</code>⁠ object, the
date-time at the end of the current time-step.</p>
<p><strong>body_mass</strong> a ⁠<code>units</code>⁠ object, defining the
agent’s body mass at the end of the current time-step.</p>
<p><strong>states_budget</strong> a named list, detailing the agent’s
time allocation across the different behavioural/activity states during
the time-step. Each element (of type ⁠<code>units</code>⁠) is named after
a specific state and stores the duration (e.g. hours) the agent spent in
that state.</p>
<p><strong>states_cost</strong> a named list, specifying the energy
costs (e.g. KJ/hr/g) associated with each state defined in state_budget.
List elements are of type ⁠<code>units</code>⁠.</p>
<p><strong>mortality_prob</strong> numeric, the probability of the agent
dying within the the current time-step (currently ignored).</p>
<p><strong>alive</strong> a logical value (TRUE if alive, FALSE if
dead), indicating whether the agent has survived the time-step.</p>
<p><strong>track</strong> object of class sf, storing a time-series of
location points tracking the agent’s movement within the current
time-step.</p>
<p><strong>energy_expenditure</strong> a ⁠<code>units</code>⁠ object,
representing the total energy (e.g. KJ/g) expended across all states
during the time-step.</p>
<p><strong>foraging_success</strong> a ⁠<code>units</code>⁠ object, the
mass of prey (e.g. grams) consumed by the agent in the current
time-step.</p>
<p><strong>mass_change_value</strong> a ⁠<code>units</code>⁠ object,
capturing the net change in the agent’s body mass (e.g., grams) over the
current time-step.</p>
</div>
<div class="section level3">
<h3 id="agent-history">Agent history<a class="anchor" aria-label="anchor" href="#agent-history"></a>
</h3>
<p>The agent’s condition is generally dynamic throughout the simulation
and can be sufficient to answer questions motivating the IBM e.g. body
mass at the end of season. More generally however, a full record may be
sought so the agent class contains a history component which stores the
agent’s condition in a spatiotemporal data structure. This allows
examination of movement, time spent in behaviour states, physical
condition etc at any point in time.</p>
</div>
</div>
<div class="section level2">
<h2 id="moving-agents-running-the-simulation-ibm-class">Moving agents, running the simulation (<code>IBM</code> class)<a class="anchor" aria-label="anchor" href="#moving-agents-running-the-simulation-ibm-class"></a>
</h2>
<p>Fundamental to the IBM is the movement of agents. Currently
<code>roamR</code> supports two movement models, which have different
data/input requirements: one relatively simple requiring only basic
knowledge of an animals speed of movement, the other a more demanding
correlated random walk that would require detailed tracking data and
parameter estimation from a Hidden Markov Model (HMM). The choice
between these will be clear - if there is not support for a fine-scale
movement model, then the simpler model will necessarily be chosen as the
turning angle, step length and correlations are not able to be
populated.</p>
<div class="section level3">
<h3 id="movement-models">Movement models<a class="anchor" aria-label="anchor" href="#movement-models"></a>
</h3>
<p>Two agent movement methods are supported, presented here in order of
complexity/data requirements.</p>
<p><strong>Density-informed</strong> this method uses density
information to generate stochastic destinations for the agents, which
are combined with activity budgets and basic speed information to give
travel paths. The process is:</p>
<ol style="list-style-type: decimal">
<li><p>Use the species’ density information in a likelihood fashion to
generate a target destination for an agent i.e. high density areas are
relatively more likely to be chosen.</p></li>
<li><p>Determine a feasible path from the current location to the
destination - <em>feasible</em> here meaning that the path does not
cross any barriers that apply from the driver response functions
(e.g. OWF, coastlines) and is within the bounding box of the
simulation.</p></li>
<li><p>The agents travel along the path is constrained/dictated by the
agent’s speed properties and activity budget over time, for example an
hour of flying within a day coupled with an average speed is used to
calculate expected travel distances, under assumed random walk
properties.</p></li>
<li><p>Iteratively regenerate destinations and paths</p></li>
</ol>
<p><strong>Correlated Random Walk (CRW)</strong> this method is
commonplace in movement simulation literature, and consists of
iteratively generating stochastic movement directions, then making a
stochastic step. The distributions can impose dependencies to provide a
directed random walk, and when related to local drivers, be functionally
responsive to the environment. The process is primarily:</p>
<ol style="list-style-type: decimal">
<li><p>Select a stochastic movement direction based on a circular
distribution (wrapped Normal in <code>roamR</code>). The mean
(direction) of the distribution may be functionally related to local
conditions e.g. vector field giving distance and direction to OWF. The
variance of this distribution imposes the correlation (low variance is
very directed movements).</p></li>
<li><p>Select a stochastic step length based on a distribution
(e.g. gamma).</p></li>
<li><p>Iterate.</p></li>
</ol>
<p>The properties of this movement can be made state dependent
e.g. flying (fast and directed), resting (stationary) - depending on the
species definition.</p>
<p>The second of these movement models is data intensive, requiring
detailed tracking information to parameterise.</p>
</div>
<div class="section level3">
<h3 id="agent-evaluations">Agent evaluations<a class="anchor" aria-label="anchor" href="#agent-evaluations"></a>
</h3>
<p>At each movement step the agents are evaluated, which includes simple
location, but storing or calculating multiple properties:</p>
<ul>
<li><p>The location and time</p></li>
<li><p>Activity state(s)</p></li>
<li><p>The cumulative net energy - based on user definitions, but
generally a function of environment and activity state e.g. the amount
of time in a feeding state, stochastic energy loss combined with local
SST and balanced against energy intake.</p></li>
<li><p>Direction of travel, speed, depending on movement model.</p></li>
<li><p>Agent body mass, depending on population of energy-to-mass
conversion functions</p></li>
</ul>
<p>Additionally, state transitions for the next step may be calculated -
as described in the state balancing section previously, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t+1</annotation></semantics></math>
activity states are related to energy intakes at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p>
</div>
</div>
<div class="section level2">
<h2 id="outputs">Outputs<a class="anchor" aria-label="anchor" href="#outputs"></a>
</h2>
<p>A principal use of the IBM is to run counterfactuals, where the
simulation is run with and without a perturbation, such as the presence
of an OWF. There are run in <code>roamR</code> in a paired fashion: the
same agents are used in both scenarios, with changes only imposed on the
definitions of the environment. Maintaining the same random seed
sequence in both cases means the paired agents will start with the same
properties, and subject to the same stochastic influences except where
the perturbation creates changes.</p>
<p>Quantification of the impact of the perturbation can be done on any
of the defined agent condition (and/or history), but likely to be
differences in:</p>
<ul>
<li><p>Cumulative net energy</p></li>
<li><p>Season-end body mass or mass change</p></li>
<li><p>Distributions of activity/behavioural states</p></li>
<li><p>Minimum body mass over the season</p></li>
<li><p>Mortality</p></li>
</ul>
<p>As a mass-agent IBM, these are not single values, but distributions
representing the variability in the simulated populations e.g. the
distribution of differences in end-of-season body mass from baseline
compared to OWF perturbation. These directly informative at a population
level, and tangible for down-stream calculations. For example, passed to
Population Viability Analyses (PVAs) where counterfactuals may use:</p>
<ul>
<li><p>Increases in mortality/proportional reductions in population
size</p></li>
<li><p>Relationships between body mass and reproductive success, to
alter PVA demographic parameters</p></li>
</ul>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>McClintock BT, Michelot T (2018). “momentuHMM: R package for
generalized hidden Markov models of animal movement.” Methods in Ecology
and Evolution, 9(6), 1518-1530. <a href="doi:10.1111/2041-210X.12995" class="uri">doi:10.1111/2041-210X.12995</a>, <a href="http://dx.doi.org/10.1111/2041-210X.12995" class="external-link uri">http://dx.doi.org/10.1111/2041-210X.12995</a>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Carl Donovan, Bruno Caneco.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
